# 典型回答

> 首先简单说一下
> 
> G1: JDK1.9中默认的垃圾回收器, 他代替了JDK1.8中默认的Parallel Scavenge GC和Parallel Old GC, 同时也替代了CMS
> 
> 很多人可能有点分不清CMS和G1的区别, 在我眼里他们确实也非常像
> 
> G1 和 CMS相比, 他们都是基于三色标记法实现的, 替代了原有的传统的可达性分析(三色标记也是可达性分析的一种, 只不过特殊一点), 可以大大的降低STW的时长, 但是, 他们之间还是有很大的不同的.
> 
> (重点看下面的表格)
> 
> 总结一下: 
> 	G1会把Java的堆分为多个大小相等的region(每个region的大小为1M-32M), 他在年轻代回收的时候采用 标记-复制 算法, 而在老年代回收的时候采用的是 标记-整理 算法, 这两种算法都可以避免内存碎片的产生. G1在回收的过程中, 标记和清理的过程是并行的, 可以充分利用CPU来缩短STW时长, 在复制的过程中是并发的, 可以让复制线程和用户线程并发执行, 不需要STW, 并且G1还可以在运行时动态的做取与内存大小的调整.

G1 是 JDK 1.9中默认的垃圾收集器，他代替了Java 8 中的默认的Parallel Scavenge GC+Parallel Old GC，并且也代替了CMS。



G1 和 CMS相比，他们都是基于三色标记法实现的，替代了原有的传统的可达性分析（三色标记也是可达性分析的一种，只不过特殊一点），可以大大的降低STW的时长。但是，他们之间还是有很大的不同的：



| **特性**      | **CMS**         | **G1**                        |
| ----------- | --------------- | ----------------------------- |
| **回收位置**    | 老年代             | 整堆                            |
| **GC算法**    | 标记-清除算法         | 标记-复制算法回收年轻代<br/>标记-整理算法回收老年代 |
| **垃圾识别算法**  | 三色标记法——增量更新解决漏标 | 三色标记法——原始快照解决漏标               |
| **碎片产生**    | 存在内存碎片          | 可防止内存碎片产生                     |
| **可预测性**    | 无法预测            | G1的STW时长可预测                   |
| **堆内存基本要求** | 一般要求不高          | 4G以上                          |
| **自适应调优**   | 不支持             | 支持                            |
|             |                 |                               |




总结一下就是，G1会把Java的堆分为多个大小相等的Region（每个Region的大小为1M-32M），他在年轻代回收的时候采用标记-复制算法，而在老年代回收的时候，采用的是标记-整理算法，这两种算法都可以避免内存碎片的产生。



G1在回收的过程中，标记和清理的过程是并行的，可以充分利用多个CPU来缩短STW的时长，在复制的过程中是并发的，可以让复制线程和用户线程并发执行，不需要STW。并且G1还可以在运行时动态的做区域内存大小的调整。

