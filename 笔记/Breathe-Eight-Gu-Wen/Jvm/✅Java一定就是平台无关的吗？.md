# 典型回答

> 不一定, 虽然Java一开始想走的路子确实是跨平台, 一份class, 可以在不同平台的JVM上运行, 并且也做了很多事情在这个上面, 也是Java的一个重要优势.
> 
> 一次编译, 到处运行!!!
> 
> 但是随着时代的发展, 云原生的概念越来越强, Java推出了很多静态编译的手段, 比如AOT和Native Image:
> 
> 	提前编译(AOT, Ahead-Of-Time Compilation): 这是将Java字节码编译成特定平台的机器码, 而不是在运行时通过JIT(Just-In-Time)编译器, 这种方式可以减少JVM启动时间并提高程序运行效率.
> 	
> 	使用GraalVM的Native Image: GraalVM允许将Java程序编译成所谓的原生映像(native image), 这是一种直接运行在操作系统上, 不需要JVM的程序.
> 
> 不论是AOT还是Native Image, 这两个都是平台相关的, 都是不依赖于JVM, 直接进行优化的操作.
> 
> 那么为什么明明已经这么多年了, Java一开始就是平台无关性的, 突然就要引入平台相关的特性?
> 
> 主要还是回应时代的发展吧, 随着云原生, Serverless的发展, 我们的代码很多时候都是部署在k8s, docker容器中的, 所以我们现在都不太关心具体的部署工作, 而是交给云服务商直接完成了, 而至于底层的具体运行的环境差别没那么明显了.
> 
> 而牺牲一定的平台无关性, 可以带来更快的启动速度, 更好的资源利用, 提供更加简单的部署过程, 何乐而不为呢?
> 
> 所以, 这并不是削弱了Java的平台无关性, 而是为了在特定场景下获取更好的性能, 选择了牺牲一定的平台无关性.

**不一定！**



虽然Java在诞生之初，设计的主要目标就是跨平台，并且也做了很多事情来让这个成为可能，也是很多年来Java的一个重要优势。



[[✅Java是如何实现的平台无关？]]



其中比较重要的就是通过JVM的平台有关来实现了java语言的平台无关。也就是说只要设备上安装了相应平台的 JVM，Java 程序就可以在任何平台上运行，不需要做任何修改。这就是“一次编写，到处运行（Write Once, Run Anywhere,）”的理念。



但是，这个事儿在现如今为了适应云原生，推出了很多静态编译的手段。比如AOT和Native Image：



1. **提前编译（AOT，Ahead-Of-Time Compilation）**：这是指将 Java 字节码编译成特定平台的机器码，而不是在运行时通过 JIT（Just-In-Time）编译器。这种方式可以减少 JVM 启动时间并提高程序运行效率。
2. **使用 GraalVM 的 Native Image**：GraalVM 允许将 Java 程序编译成所谓的“原生映像”（native image），这是一种直接运行在操作系统上，不需要 JVM 的程序。



[[✅什么是AOT编译？和JIT有啥区别？]]



不管是通过AOT编译把代码翻译成机器码，还是Native Image来消除JVM，最终都是是平台相关的了。



# 扩展知识


## 为什么Java要走回头路？


明明Java是靠着跨平台，平台无关性起家的，并且这么多年来这一直都是他的一个非常大的优势， 为什么如今要走到一条平台有关的路上来呢？



主要是因为在当今的云原生 Serverless的环境下，平台无关已经不再那么重要了。而且很多时候我们的代码都是部署在k8s、docker等容器中的。所以很多时候我们都不太关心具体的部署工作，而是交给云服务商直接完成了。而至于底层的具体运行的环境差别并没有那么明显了。



而牺牲一定的平台无关性，可以带来更快地启动速度、更好的资源利用、提供更加简单的部署过程，何乐而不为呢？



所以，这并不是削弱了 Java 的平台无关性，而是为了在特定场景下获得更好的性能和资源利用率，选择了牺牲一定程度的平台无关性。

