# 典型回答

> 为什么是小表驱动大表性能高, 这一切是站在索引的角度谈的, 一旦脱离了索引, 一切都是白说, 因为join其实就是嵌套循环, 如果没有索引的话, 不管是小表驱动大表还是大表驱动小表, 复杂度分别是O(100) * O(10000), O(10000) * O(100), 其实没有差别, 只是顺序问题, 但是一旦通过连接的那个键有索引的话, 因为索引的B+树查询性能和二分是一个复杂度, 直接就会变成O(100) * O(log10000), O(10000) * O(log100), 这就不用说哪个效率高了吧, 所以要用小表驱动大表

- [x] MySQL为什么是表驱动大表, 为什么能提高查询性能.  [completion:: 2025-08-15]

正常来说, 在不考虑索引的情况下, 我认为性能是没有明显差异的, 可以把笛卡尔积看成两层for循环, 但是如果有索引那么最外层那个for循环就会加一个log, 这样的话如果将大表走log的话, 性能明显更高.


[[✅MySQL的驱动表是什么？MySQL怎么选的？]]



我们介绍过，当进行联接查询时，MySQL 通常会选择较小的表作为驱动表，然后在较大的表中查找匹配的记录。这种策略的核心思想是减少扫描和比较的次数，从而提高查询性能。



假设我们有两个表：employees（1000 条记录）和 departments（10 条记录），并且要进行以下查询：



```java
SELECT e.name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.id
```



在不考虑hash join等其他链接方式，只考虑nested loop join的情况下，其实执行的次数是笛卡尔积，即：



```java
for(1000){
    for(10)
}

和

for(10){
    for(1000)
}
```

  
但是，假设employees.department_id和departments.id 都有索引的情况下，就不一样了，因为索引的查询是比较快的，他的复杂度是log(n)。那么：



大表驱动小表，复杂度为：O(1000) * O(log 10)

小表驱动大表，复杂度为：O(10) * O(log 1000)



这样一算的话，就非常清楚了，肯定是小表驱动大表的整体的复杂度更低！

