# 典型回答

> 排他锁: 这是在写操作上的锁, 在写的时候会获取这个锁, 然后其他事务不可以并发访问或修改这行数据
> 
> 共享锁: 这是读操作上的锁, 他不会阻塞其他的读操作, 所有的读操作都可以取访问被共享锁锁上的数据, 但是如果你想修改数据, 在你尝试加排他锁的时候了, 共享锁和排他锁是互斥的, 所以会报错.
>        共享     排他
> 共享     Y       X
> 排他     X       X
> 
> 关系大概就是上面内样

**共享锁又称读锁，是读取操作创建的锁**。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。



如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。**获得共享锁的事务只能读数据，不能修改数据。**



```plain
SELECT ... LOCK IN SHARE MODE;
```



在查询语句后面增加LOCK IN SHARE MODE，MySQL会对查询结果中的每行都加共享锁，被加了共享锁的记录还可以被其他事务成功申请共享锁，但是不能被申请排他锁。



**排他锁又称写锁，**如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的锁。**获得排他锁的事务既能读数据，又能修改数据。**



```plain
SELECT ... FOR UPDATE;
```



在查询语句后面增加FOR UPDATE，MySQL会对查询命中的每条记录都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。



总结：

**当这一行数据获取了排他锁，那么其他事务就不能在对这一行数据添加共享锁或者排他锁。**

**当这一行数据获取了共享锁，那么其他事务依然可以对这一行数据添加共享锁，但不能添加排他锁**

