# 典型回答

> RDB:
> 	可以设置两个参数, 一个是时间, 一个是发生变化的key, 如果满足在这个时间内至少有n个key发生变化, 我们就保存快照.
> 	rdb有两种方式:
> 		1. save: 阻塞redis直到快照完成
> 		2. bgsave: fork一个子进程, 然后生成快照, 不会阻塞redis
> AOF:
> 	AOF有三个参数:
> 	1. always: 同步写回, 每个写命令执行完, 立马把日志刷新到磁盘
> 	2. everysec: 每秒写完, 每个写命令执行完, 先放到写入缓冲区中, 然后每秒进行刷新.
> 	3. no: 操作系统来进行写回, redis不进行处理, 放到写入缓冲区中, 由操作系统决定啥时候写回磁盘.
> 	同步肯定效率最高, 但是每写一下都得写磁盘, 肯定会影响效率, 这和写磁盘的数据库有什么区别呢, 如果是操作系统决定刷新磁盘, 这是最不靠谱的, 万一还没写就宕机了, 不就jj了, everysec是相当于是取了个折中, 异步写入磁盘, 最大程度提高效率和降低风险.

[[✅Redis的持久化机制是怎样的？]]



**写回策略**是指将数据从内存写入到持久化存储（如磁盘）的方式和时机。在Redis中，不同的持久化机制有着不同的写回策略。


	
## RDB的写回策略
在 Redis 中，RDB 的写回策略主要包括以下几个方面：



#### 定期触发


Redis通过配置文件中 `save` 参数定义了 RDB 的自动保存条件。以下是默认配置的示例：



```nginx
save 900 1    # 如果900秒内至少有1个键发生变化，则保存快照
save 300 10   # 如果300秒内至少有10个键发生变化，则保存快照
save 60 10000 # 如果60秒内至少有10000个键发生变化，则保存快照
```

**策略**：

+ Redis会定期检查这些条件，如果满足，触发 RDB 的保存操作。
+ 条件可以通过修改 `redis.conf` 文件自定义，也可以通过命令动态设置，例如：

```shell
CONFIG SET save "300 10 60 10000"
```



#### 手动触发
在Redis中，我们可以通过以下命令手动生成 RDB 文件：



+ **SAVE**：会阻塞 Redis 服务器，直到快照完成。
+ **BGSAVE**：在后台异步生成 RDB 文件，不会阻塞 Redis。



`SAVE` 操作直接在主线程完成，不适合生产环境。`BGSAVE` 会 fork 一个子进程生成快照，更高效，但需要一定的系统资源（如内存和CPU）。



## AOF的写回策略


AOF有三种数据写回策略，分别是Always，Everysec和No。



+ **Always**，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
+ **Everysec**，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
+ **No**，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。



“同步写回”可靠性肯定是最高的，但是它在每一个写命令后都有一个落盘操作，而且还是同步的，这和直接写磁盘类型的数据库有啥区别？



"操作系统控制的写回"这种是最不靠谱的，谁知道操作系统啥时候帮你做持久化，万一没来及持久化就宕机了，不就gg了。



"每秒写回"是在二者之间折中了一下，异步的每秒把数据写会到磁盘上，最大程度的提升效率和降低风险。

