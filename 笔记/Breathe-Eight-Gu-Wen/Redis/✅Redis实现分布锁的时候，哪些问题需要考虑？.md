# 典型回答

> 实现一个锁, 必须考虑的点容易想到的就是
> 	锁的互斥性
> 	锁的可重入性
> 	锁的性能
> 	误解锁问题
> 	锁的有效时间
> 	......
> 	接下来几个不太好想
> 	单点故障
> 	网络分区
> 	时钟漂移
> 锁的互斥性:
> 	可以借助setnx来完成, 因为这个操作本身就是一个原子性操作, 并结合redis的单线程的机制来保证互斥性.
> 锁的可重入性:
> 	这其实就是说一个线程拿到了一个锁, 可以反复的获取到同一把锁, 这个其实也很好做到, redisson不就是基于hash做到的吗, field存threadId, value存次数
> 锁的性能:
> 	没有人会质疑redis的性能吧, 这是基于内存实现的, 肯定非常不错.
> 误解锁问题:
> 	这个东西完全可以将线程ID或一些能够保证唯一性的参数放到redis的锁的信息中,需要做一下判断
> 锁的有效时间:
> 	我认为这是必须设置的一个参数, 防止由于一些故障, 解不了锁, 那不是炸了吗, 这把锁一直得不到释放, 导致后面的业务全部阻塞住, 所以我认为这个必须要有兜底, 但是设置的时间太长影响业务, 太短业务没执行完就释放会导致并发问题, 所以这里不太好把握, 我认为最好就像redisson一样, 实现一个watchdog机制.
> 单点故障
> 	有了自动续期以后, 锁也不一定可靠, 他可能会遇到两个单点问题.
> 	单机:
> 		如果挂掉以后, 所有使用这个实例的客户端都无法获取锁, 这个很好理解, 并且这个问题很好解决, 用集群不就好了
> 	集群:
> 		集群其实也会遇到单点故障问题, 主要是由于redis的集群是AP的, 他的数据同步可能不及时. 他刚创建出来这个锁, 然后还没来得及同步就挂了, 然后那么就相当于这个锁被解锁了(不存在了已经), 所以这时候也会出现并发问题.
> 	为了解决这些问题, 提出了RedLock, 好几个redis节点同时加锁, 半数以上加锁成功就加锁, 这样即使之前的master挂了, 后来的master也会有锁的数据.
> 网络分区
> 	如果发生脑裂, 出现两个master, 那么这个锁也就会在两个分区分成两份都会获取到同样的锁也会发生问题.
> 时钟飘逸
> 	我们每台机器的时钟肯定多多少少会发生偏移, 这会导致失效的时间不一致, 导致锁释放的时间不一致, 就导致虽然还不能释放锁, 但是有的节点已经释放了, 并且重新获取, 也会造成并发问题, 这时候可以使用NTP等工具来同步不同机器的时间.

这是一个比较典型的关于Redis分布式锁的综合性问题，其实考察的就是关于分布式锁的熟悉程度，尤其是Redis的分布式锁的熟悉程度。



我总结了一下关于这个问题可以回答的几个方向和关键点。



### 锁的基本要求


一个分布式锁有很多基本要求，比如说锁的**互斥性**、**可重入性**、**锁的性能**等问题。



对于锁的互斥性，可以借助setnx来保证，因为这个操作本身就是一个原子性操作，并且结合Redis的单线程的机制，就可以保证互斥性。



[[✅Redis中的setnx命令为什么是原子性的]]



因为Redis是基于内存的，所以他的性能也是很高的，这个就没啥好说的了，大家都知道的。



[[✅Redis为什么这么快？]]



至于可重入性，其实就是说一个线程，在锁没有释放的情况下，他是可以反复的拿到同一把锁的。并且需要在锁中记录加锁次数，用来保证重入几次就需要解锁几次。用setnx也是可以实现的。



[[✅如何用setnx实现一个可重入锁？]]





当然，如果我们直接使用Redisson的话，他是支持可重入锁的实现的。可以直接用。



[[✅如何用Redisson实现分布式锁？]]



### 误解锁问题


其实就是要确保只有锁的持有者能释放锁，避免其他客户端误解锁。这个问题其实挺傻的，但是我们实际就发生过，因为有的时候我们是在finally中去释放锁，finally有一定会执行，那么就可能会导致虽然没拿到锁，但是当他执行finally的时候，也可能把锁给解了。



所以，需要解决这个问题，我们就需要在使用setnx加锁时把具体持有锁的owner放进去，和上面一样，线程ID也好，业务单号也好，总之需要做一下判断。



如果用了Redisson是不存在这个问题的。



### 锁的有效时间


为了避免死锁，我们一般会给一个分布式锁设置一个超时时间，如上面我们用的setnx的方案，其实就是设置了一个超时时间的。



但是有的是，代码如果执行的比较慢的话，比如设置的超时时间是3秒，但是代码执行了5秒，那么就会导致在第三秒的时候，key超时了就自动解锁了，那么其他的线程就可以拿到锁了，这时候就会发生并发的问题了。



所以，我们需要有一个好的办法来解决。一种是设置一个更长的超时时间，避免提前释放，我见过有人把分布式锁设置半个小时。。。



但是这个方案非常不好，因为分布式锁是影响并发的，锁的时间长，意味着加锁时间段内只能有一个线程操作，那么并发度就会大大降低。（因为要考虑到解锁失败的问题）



还有一个好的办法，就是像redisson一样，实现一个watch dog的机制，给锁自动做续期，让锁不会提前释放。



[[✅Redisson的watchdog机制是怎么样的？]]



但是需要注意的是，只有我们没有自己主动设置锁的超时时间的时候，watchdog才会续期，如果自己设置了超时时间，那么就不会给你续期了。具体看上面这个原理解读。



### 单点故障问题


有了自动续期之后，锁就一定可靠了吗？其实也不是，这里会存在两个单点问题。



首先，在使用单节点Redis实现分布式锁时，如果这个Redis实例挂掉，那么所有使用这个实例的客户端都会出现无法获取锁的情况。



这个问题是有解的，就是引入集群模式，通过哨兵检测redis实例挂掉的情况，提升整个集群的可用性。



[[✅介绍一下Redis的集群模式？]]



但是，这个方案同样存在一个单点故障带来的问题：



当使用集群模式部署的时候，如果master一个客户端在master节点加锁成功了，然后没来得及同步数据到其他节点上，他就挂了， 那么这时候如果选出一个新的节点，再有客户端来加锁的时候，就也能加锁成功，因为数据没来得及同步，新的master会认为这个key是不存在的。



为了解决这个问题，redis的作者提出了一个算法——RedLock，他通过这种算法来保证在半数以上加锁成功才认为成功，这样就可以确保即使master挂了，新选出来的master也会有之前的加锁数据。



具体原理见：



[[✅什么是RedLock，他解决了什么问题？]]





### 网络分区问题


但是，引入红锁就万事大吉了么。也并不是。红锁同样存在问题。首先就是一个网络分区的问题。



在网络分区的情况下，比如集群发生了脑裂，不同的节点可能会获取到相同的锁，这会导致分布式系统的不一致性问题。



[[✅介绍下Redis集群的脑裂问题？]]



但是我们需要注意的是，这个情况虽然会存在节点获取到相同锁，但这种情况只会发生在网络分区发生时，且只会发生在一小部分节点上。而在网络分区恢复后，RedLock 会自动解锁。所以理论上来说是有这个风险，但是实际上来说发生的概率极低。



### 时间漂移问题


除了脑裂，还有一个时钟飘移的问题，由于不同的机器之间的时间可能存在微小的漂移，这会导致锁的失效时间不一致，也会导致分布式系统的不一致性问题。



那么就会导致有的redis实例已经解锁了，那么就会使得新的客户端可以拿到锁。



这个问题的解决方案是，RedLock 可以使用 NTP 等工具来同步不同机器之间的时间，从而避免时间漂移导致的问题。

