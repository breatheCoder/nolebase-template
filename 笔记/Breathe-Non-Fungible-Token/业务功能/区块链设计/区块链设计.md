## 一、系统设计
### 时序图
用户实名认证时，创建链账户

![[c63dd2ee-fc7d-4734-a2a2-eab2a7669a35.png]]

在用户实名认证之后，我们需要在链平台上给用户创建一个独一无二的链账户，只有有了账户之后，用户才能进行区块链相关的交易。所以这一步比必须要，相当于给用户开了个户。

藏品发生交易时，调用链进行上链



![[9f5e2215-5fc9-47a7-8d58-9e1e7780fab0.svg]]



在藏品的交易相关过程中，我们主要抽象出了几个方法，分别介绍下：

+ 上链藏品
+ 可以把它理解为模板，即在链上创建一个藏品的基本信息，比如我们要发行100份电影票，只需要上链一次即可，后续有了这个电影票的基本信息，我们就可以基于他做出售。
+ 铸造藏品
+ 可以把他理解为基于模板创建出来的实例。上链后的藏品，想要被拥有，需要经过铸造过程，铸造依赖上链，只有上链后才能铸造。铸造之后的藏品需要有一个归属人，这个归属人就是为什么之前要创建链账户。
+ 交易藏品
+ 可以把他理解为实例的转手。铸造后的藏品，可以转让、交易给其他人，其实就是归属人的变更。
+ 销毁藏品
+ 一个藏品如果不想要了，则支持销毁。

## 二、接口设计
```java
public interface ChainFacadeService {

    /**
     * 创建链账户
     *
     * @param request
     * @return
     */
    ChainProcessResponse<ChainCreateData> createAddr(ChainProcessRequest request);

    /**
     * 上链藏品
     *
     * @param request
     * @return
     */
    ChainProcessResponse<ChainOperationData> chain(ChainProcessRequest request);

    /**
     * 铸造藏品
     *
     * @param request
     * @return
     */
    ChainProcessResponse<ChainOperationData> mint(ChainProcessRequest request);

    /**
     * 交易藏品
     *
     * @param request
     * @return
     */
    ChainProcessResponse<ChainOperationData> transfer(ChainProcessRequest request);

    /**
     * 销毁藏品
     *
     * @param request
     * @return
     */
    ChainProcessResponse<ChainOperationData> destroy(ChainProcessRequest request);
}
```

## 三、数据库设计
![[4689e248-e5e3-4e32-b224-607aba9bbb99.jpeg]]

因为是记录和外部平台的交互，我会在其中记录一下每次交互的一个日志，然后根据其中的成功状态，看看定时任务会不会进行重试。



## 四、设计亮点
### <font style="color:rgb(38, 38, 38);">工厂模式进行路由区块链服务</font>
目前支持文昌链和mock场景

```java
@Service
public class ChainServiceFactory {

    @Autowired
    private final Map<String, ChainService> chainServiceMap = new ConcurrentHashMap<String, ChainService>();

    public ChainService get(ChainType chainType) {
        String beanName = BeanNameUtils.getBeanName(chainType.name(), "ChainService");

        //组装出beanName，并从map中获取对应的bean
        ChainService service = chainServiceMap.get(beanName);

        if (service != null) {
            return service;
        } else {
            throw new UnsupportedOperationException(
                    "No ChainService Found With chainType : " + chainType);
        }
    }
}
```

