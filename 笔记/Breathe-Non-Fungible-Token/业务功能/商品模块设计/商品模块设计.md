我们的项目中，已经有一个 collection、box 等模块了，他们都是具体的商品了，但是我们还是单独定义了一个 goods 模块，为啥要单独弄一个商品模块呢？



![[be0c4010-1366-439b-8917-04d35ddcc566.png]]



这部分代码我们做了重构，最开始只有 collection 模块，后来新增了 goods 模块，但是在做了盲盒功能之后，我又把他们三个模块之间的关系给改了。改成现在的 goods 模块中包含 collection 和 box 两个子模块的方式 。



## 为啥要有goods模块
其实主要是为了抽象出来一个商品域，把底层的商品细节类型屏蔽掉，因为我们的项目有collection和blind-box。



所以我们为了定义一个goods模块，用于让goods和trade，order来交互，屏蔽掉底层的差异，要不然我每多一种商品类型，都需要和这些模块做一层交互。

![[19d66333-edcb-4986-810a-634ef2c592fe.png]]



goods这一层不要做存储，最多就是和缓存交换一下而已，这种是座一层包装，所以这一层很多时候都被叫做防腐层。



为什么又把三个模块合到一起了。



最开始这么设计的时候，我是有三个模块的，有collection和blind-box和goods的，这三个模块平行，然后请求先打到goods层，然后goods再和collection和box交互，这中间如果拆分为多个服务的话就会多一次网络开销。



![[73dbb7ec-3e67-48fe-940a-adf36dda994e.png]]



在这个项目中，我们的主要目的就是为了做高并发，这种多余的网络开销肯定是不想看到的，他可能会妨碍性能，于是我想了个办法，模块还是三个模块，但是把他们部署到一起。



最上面有一个goods模块，然后他包含两个子模块collection和box就行了，但是后来发现一些屏蔽差异的代码没地方改了，所以有包装了一层interface层，这里主要是写的是接口和与上游网络交互屏蔽的，具体的实现逻辑都在box和collection中。

![[9dbb5e2f-36a1-475a-84af-5c2926efd0d4.png]]

这样既可以各个模块之间不互相影响，又可以做到上游系统只需要和goods做交互，还能做到没有额外的网络开销，又快又好。



设计的一些类的时候都会在goods这一层封装一层抽象类，box和collection的一些具体的实现是直接继承这个抽象类，然后返回的时候就返回这些的实现类就可以的。

