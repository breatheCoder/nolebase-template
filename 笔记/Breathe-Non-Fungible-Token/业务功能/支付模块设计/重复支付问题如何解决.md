- [x] 重复支付问题如何解决  [completion:: 2025-08-17]

## 为什么会重复支付

大家看了支付这部分的代码应该会知道，在生成支付链接的时候，我们是做了幂等控制的，严格的遵守了"一锁、二判、三更新"的。

![[Pasted image 20250817001511.png]]

这样确实可以保证幂等，但是，如果大家仔细看的话，会发现，我们在查询支付单的时候，条件如下：

```java
PayOrder selectByBizNoAndPayer(String payerId, String bizNo, String bizType, String payChannel);
```

付款方、订单号（业务单号+业务类型）、支付渠道，是用这三个关键信息做的唯一性检查。那么也就说，如果用户针对同一笔订单，换了一个支付方式的话，比如之前用微信、现在改用支付宝，那么就可以重新发起一次新的支付了。

虽然我们加的分布式锁是针对bizNo 也就是订单号加的锁，但是分布式锁防的是并发，如果没有并发呢？看一下这个真实场景：

用户下单后，先用微信支付去付款，用微信支付扫码后，因为网络问题，一直转圈圈。用户以为支付失败了。他关闭微信的手机进程，重新回到订单这里，换用支付宝付款。付款成功。

但是，之前那笔微信支付的付款操作，是有可能实际支付成功的。那么一旦他成功了，就意味着同一笔订单，微信、支付宝都支付成功了，这就发生了重复支付的问题。而且这个问题没办法防止，你总不能要求用户微信支付发起后，就不能再发起支付宝支付了吧。万一用户微信钱不够，想换支付宝付款，这再正常不过了。

还有一种多付的场景，那就是用户已经尝试支付的时候，支付单还未失效，然后去微信支付了，但是支付

所以，我们需要通过技术手段来识别并解决这个问题。

## 如何识别多付?

那么，我们如何识别出一笔订单多付了呢？

1. 订单需要有一个明确的状态, 记录下来的订单已经被支付成功过了
2. 订单上需要记录是哪笔支付单最终把他推进到支付成功了, 具体的就是哪个渠道和哪笔订单的交易记录.
3. 支付成功回调接受到时, 判断订单状态是否已支付.
	1. 如果订单状态为未支付成功, 说明当前是第一次支付成功.则把订单推进到已支付成功, 并记录当前的渠道和渠道流水号.
	2. 如果支付单对应的订单已经支付成功了, 则判断当前订单上记录的渠道和渠道流水号和本次成功的渠道号和流水号一样吗
		1. 如果一致, 说明是消息重投了, 直接做幂等操作处理.
		2. 如果不一致, 说明多付了, 则执行退款操作.

![[Pasted image 20250817002355.png]]

> 至于考虑到微信同时过来两个支付链接, 其实是不可能出现的, 我们已经做了幂等校验, 用了一锁二判三更新, 是不会出现非幂等, 但这里出现的这个多付问题不是加分布式锁能解决的, 所以就得单独处理, 并且出现多付的场景只可能是多个支付渠道, 

> 如果微信一直转圈圈, 然后他退出, 然后点击微信重新支付, 这种情况如何处理呢?会发生支付问题吗? 其实也不会, 我们在重新点微信支付的时候, 我们是有一个幂等判断的, 如果已经生成这个支付单了, 就会直接返回这个支付单, 那就不会发生并发问题.

```java
public PayOrder create(PayCreateRequest payCreateRequest) {  
    PayOrder existPayOrder = payOrderMapper.selectByBizNoAndPayer(payCreateRequest.getPayerId(), payCreateRequest.getBizNo(), payCreateRequest.getBizType().name(), payCreateRequest.getPayChannel().name());  
	//就是这一行解决上面的微信转圈圈的问题.
	//我如果二次通过相同的方式创建支付单的话, 我们会通过一次查询, 如果存在且订单状态不为expired的话, 就直接返回.
    if (existPayOrder != null) {  
        if (existPayOrder.getOrderState() != PayOrderState.EXPIRED) {  
            return existPayOrder;  
        }  
    }  
    PayOrder payOrder = PayOrder.create(payCreateRequest);  
    boolean saveResult = save(payOrder);  
    Assert.isTrue(saveResult, () -> new BizException(RepoErrorCode.INSERT_FAILED));  
  
    return payOrder;  
}
```

## 如何处理多付

多付了怎么办？退款呗。原路把钱给用户退回去。比如微信支付，直接调用它的退款的接口就行了。

但是因为这里是和资金相关，并且是和退款有关，比较敏感，并且还要和外部机构交互，所以我们需要记录一些退款相关的信息。所以我们定义了一个退款单的模型，用来记录退款的信息。

![[Pasted image 20250817003049.png]]

具体的代码实现如下：

```java
private void doChargeBack(PaySuccessEvent paySuccessEvent, TradeOrderVO tradeOrderVO) {  
    RefundCreateRequest refundCreateRequest = new RefundCreateRequest();  
    refundCreateRequest.setIdentifier(paySuccessEvent.getChannelStreamId());  
    refundCreateRequest.setMemo(REFUND_MEMO_PREFIX + tradeOrderVO.getOrderId());  
    refundCreateRequest.setPayOrderId(paySuccessEvent.getPayOrderId());  
    refundCreateRequest.setRefundAmount(paySuccessEvent.getPaidAmount());  
    refundCreateRequest.setRefundChannel(paySuccessEvent.getPayChannel());  
    RefundOrder refundOrder = refundOrderService.create(refundCreateRequest);  
    Assert.notNull(refundOrder, () -> new BizException(PayErrorCode.REFUND_CREATE_FAILED));  
  
    //异步进行退款执行，失败了交给定时任务重试  
    Thread.ofVirtual().start(() -> {  
        RefundChannelRequest refundChannelRequest = new RefundChannelRequest();  
        refundChannelRequest.setRefundOrderId(refundOrder.getRefundOrderId());  
        refundChannelRequest.setPaidAmount(MoneyUtils.yuanToCent(refundOrder.getPaidAmount()));  
        refundChannelRequest.setPayChannelStreamId(refundOrder.getPayChannelStreamId());  
        refundChannelRequest.setPayOrderId(refundOrder.getPayOrderId());  
        refundChannelRequest.setRefundAmount(MoneyUtils.yuanToCent(refundOrder.getApplyRefundAmount()));  
        refundChannelRequest.setRefundReason(refundOrder.getMemo());  
  
        RefundChannelResponse refundChannelResponse = payChannelServiceFactory.get(paySuccessEvent.getPayChannel()).refund(refundChannelRequest);  
  
        if (refundChannelResponse.getSuccess()) {  
            refundOrderService.refunding(refundOrder.getRefundOrderId());  
        }  
    });  
}
```

并在退款成功后，渠道会有回调通知，接收到通知后，推进退款单和支付单状态：

```java
@Transactional(rollbackFor = Exception.class)  
public boolean refundSuccess(RefundSuccessEvent refundSuccessEvent) {  
    RefundOrder refundOrder = refundOrderService.queryByOrderId(refundSuccessEvent.getRefundOrderId());  
    if (refundOrder.isRefunded()) {  
        return true;  
    }  
  
    boolean refundResult = payOrderService.refundSuccess(refundSuccessEvent)  
            && refundOrderService.refundSuccess(refundSuccessEvent);  
  
    Assert.isTrue(refundResult, () -> new BizException(PayErrorCode.REFUND_SUCCESS_NOTICE_FAILED));  
  
    return true;  
}
```