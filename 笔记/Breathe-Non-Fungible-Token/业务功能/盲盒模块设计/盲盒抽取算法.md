盲盒的抽取，背后是需要算法来实现的，在业内，盲盒的抽取算法一般有以下几种：



1、纯随机：每个藏品按照设定的概率随机分布，玩家抽取时直接按概率生成结果。

2、加权随机：给不同的用户设置权重，根据权重决定藏品被抽取的概率。

3、分层随机：给不同的用户做分层，每个分层只能随机到本层的藏品

4、保底机制：在一定次数未抽到稀有物品时，系统自动触发奖励，确保玩家获得稀有物品。

5、阶梯概率提升：随着抽取次数增加，稀有物品的概率逐步提升，直到抽取到稀有物品后概率重置。



这里面，最基本的即是纯随机方式，其他的方式都是在纯随机的基础上衍生出来的。



在我们的项目中，我们目前只实现了一种随机方式，但是预留了支持多种算法的接口



我们定义了一个BlindBoxRuleService，是盲盒抽取的服务，新的算法只需要实现这个服务即可。



当然，新算法想要生效，还需要遵守一个约定，那就是你的 Service 的名字的前缀，需要和BlindAllotBoxRule的枚举项能对应的上，这样才会自动的路由，否则需要手动修改cyou.breathe.nft.box.domain.service.BlindBoxRuleServiceFactory#get



```java
public enum BlindAllotBoxRule {
    /**
     * 随机
     */
    RANDOM;
}
```



如RandomBlindBoxRuleServiceImpl，就是一个随机抽取算法的具体实现：



```java
/**
 * 随机盲盒规则实现
 *
 */
@Service("randomBlindBoxRuleService")
@Slf4j
public class RandomBlindBoxRuleServiceImpl implements BlindBoxRuleService {

    @Autowired
    private BlindBoxItemService blindBoxItemService;

    @Override
    public Long match(BlindBoxBindMatchRequest request) {
        return blindBoxItemService.queryRandomByBoxIdAndState(request.getBlindBoxId(), BlindBoxItemStateEnum.INIT.name());
    }
}
```



他的实现逻辑比较简单，那就是调用了底层的queryRandomByBoxIdAndState方法，具体实现如下：



```java
    <select id="queryRandomByBoxIdAndState" resultType="java.lang.Long">
        SELECT id FROM blind_box_item
        WHERE blind_box_id = #{blindBoxId} AND state = #{state}
        ORDER BY RAND() LIMIT 1
    </select>

```



通过 SELECT xxx FROM xxx WHERE xxx ORDER BY RAND() LIMIT 1 实现随机获取一个，并且通过WHERE blind_box_id = #{blindBoxId} AND state = #{state}来过滤获取到指定的盲盒中还未被别人开盒的商品。



这个过程可能会有个并发的可能 ，那就是大家都查询到了同一条，最终在更新的时候，因为我们的 update 是有乐观锁的，所以只有一个用户可以成功，其他人会失败。

