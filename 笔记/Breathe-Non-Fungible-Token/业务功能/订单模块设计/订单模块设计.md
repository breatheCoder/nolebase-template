订单模块，是我们项目中	最重要的一个模块了，他的职责就是提供订单相关的管理和查询等功能。



![[72e311fe-37fa-4350-9a4c-4999c302ebdf.png]]



这个模块我们按照功能分别介绍

## 模型设计
![[98eeba0d-1d1d-4bfd-b76d-48c661cf0139.jpeg]]

做了一个反范式，避免重复查询数据库或多表联查



## 状态机
![[fe51f65c-abba-4af6-8e1b-39322d7afced.jpeg]]

为什么会有discard呢？看样子好像和TCC的空悬挂和空回滚有关



![[79cb84c9-6b4e-4ecf-9a35-328d0e449f66.png]]

[[订单为什么没有PAYING状态]]


## 业务流程
### 下单
**方案一、基于inventoryHint**

[[秒杀第一套方案：基于InventoryHint实现库存的热点扣减]]
![[877cb62b-216a-4ac2-aacf-ee8ebdf32f5b.svg]]

这里关于库存扣减部分大家直接看库存相关设计即可，订单部分我们重点介绍下。



这部分，我们在订单扣减的时候，用了一个自发自收的内部事件，这个事件主要起到一个缓冲的作用，另外，也是适当的解耦。



这里没用 RocketMQ，而是用了 Spring的Event 机制+XXLJOB 重试来保障的。



这部分成功之后，订单状态会变成 CONFIRM，这个状态下的订单就可以支付了。



**方案二、基于rocketmq**

[[秒杀第二套方案：基于Redis+MQ+数据库实现高并发扣减]]

这个方案主要是针对如果数据库不支持inventoryHint的话，我们采用rocketmq来削峰填谷。

![[e73b5629-ec42-41a3-9b58-ea84543c60a5.svg]]

### 支付
![[27da55d6-7aac-4503-8615-7c2af1bc1caa.svg]]



这里的订单不仅要做自己的状态突进，还需要做单笔订单只能支付成功一次的管控，避免用户出现多付，如果出现多付，则需要进行退款。



在支付成功后，订单状态则推进到 PAID



### 取消订单
![[39375518-9d44-415a-b678-99760c5e0f7b.svg]]

这里我们为了保证取消订单和库存回退的数据一致性，利用了 RocketMQ 的事务消息。



当订单取消后，状态变成 CLOSED，closeType为CANCEL。

### 超时关单
订单的关闭，除了用户主动取消外，还会有超时关单的情况。超时关单的逻辑和用户主动取消的逻辑其实是一样的，只不过入口不一样。



超时关单主要是由定时任务触发的，也有的是用户主动访问订单的时候也可能会触发已超时的订单的关单。但是不管怎么样，后续处理逻辑一样。



当订单超时后，状态变为CLOSED，closeType为TIME_OUT

## 交易完成
订单还有最后一个操作，那就是当交易成功后，持有藏品完成创建，并且上链成功后，则推进到交易完成状态。



这一阶段执行完之后，订单状态为 FINISH。

