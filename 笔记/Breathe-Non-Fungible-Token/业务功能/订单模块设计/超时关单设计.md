在订单的超时关单的设计中，我们为了提升扫表性能，做了一下几个事情：

1. 主动关单

//TODO

2. XXL-JOB分片任务 -》 没有用MQ

//TODO

3. 生产者消费者模式-BlockingQueue

`BlockingQueue`其实就是阻塞队列，是基于阻塞机制实现的线程安全的队列。

`BlockingQueue`的特点是当队列满时，会阻塞入队的线程，直到队列不满；当队列为空时，会阻塞出队的线程，直到队列中有元素。

`BlockingQueue`常用于**生产者-消费者模型**中，往队列里添加元素的是生产者，从队列中获取元素的是消费者；通常情况下生产者和消费者都是由多个线程组成；下图所示则为一个最常见的**生产者-消费者模型**，生产者和消费者之间通过队列平衡两者的的处理能力、进行解耦等。

线程池-ForkJoinPool

**ForkJoinPool 是基于工作窃取（Work-Stealing）算法实现的线程池**，		ForkJoinPool 中每个线程都有自己的工作队列，用于存储待执行的任务。当一个线程执行完自己的任务之后，会从其他线程的工作队列中窃取任务执行，以此来实现任务的动态均衡和线程的利用率最大化。

毒丸对象

因为用到了`BlockingQueue`，他的特点是从里面读取元素的时候，如果里面没有了，他就会一直阻塞。

但是 Queue 中没有元素，有可能是消费者的消费速度比生产者块，导致还没来得及生产，阻塞一会还是可以等到新的任务的。

还有一种情况，那就是生产任务已经完成了，这时候就应该退出任务的执行。那么如何识别这种情况，让任务退出执行呢。

我们定义了一个毒丸对象，在生产者生产完成之后，向队列中加入一个毒丸对象，这样消费者在取到这个毒丸对象的时候，就知道可以结束消费了。

