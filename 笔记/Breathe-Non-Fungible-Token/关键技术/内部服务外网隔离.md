我们的项目中提供了很多子服务，他们都是提供了web访问入口的，比如User，Trade等模块，如果知道应用启动端口号就能直接通过端口访问。



这样就会存在绕过网关访问内网服务的风险，所以我们需要提供一套机制来实现逻辑隔离

即：子服务与网关同时暴露在外网，但是子服务会有一个权限拦截层保证只接受网关发送来的请求，绕过网关直接访问子服务会提示：无效请求



我们的项目中就是借助了satoken实现的这个功能，主要原理就是在gateway中管理一个授权，并且在子服务中进行校验，如果有这个授权，则认为请求是网关过来的，否则就不是，就可以直接拒绝掉请求。



主要实现方式如下：



1. 在网关中埋点SAME_TOKEN

```java
@Component
public class AuthFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();

        // 修改请求头
        request = request.mutate()
                .header(SaSameUtil.SAME_TOKEN, SaSameUtil.getToken())
                .build();

        ServerWebExchange newExchange = exchange.mutate().request(request).build();
        return chain.filter(newExchange);
    }
}
```



以上代码在Gateway的应用中添加。



2. 在子服务中进行token校验

```java
@AutoConfiguration
@ConditionalOnWebApplication
public class WebConfiguration implements WebMvcConfigurer {

    @Bean
    @ConditionalOnMissingBean
    GlobalWebExceptionHandler globalWebExceptionHandler() {
        return new GlobalWebExceptionHandler();
    }

    /**
     * 注册 Sa-Token 全局过滤器
     */
    @Bean
    public SaServletFilter getSaServletFilter() {
        return new SaServletFilter().addInclude("/**").setAuth(obj -> {
            SaSameUtil.checkCurrentRequestToken();
        }).setError(e -> SaResult.error(e.getMessage()));
    }
}
```



在子服务中增加对token的校验，如果校验失败则无法访问。

