在我们的项目中，为了保证一致性，引入了多种分布式事务的方案。



在行业内，用的比较多的分布式事务的方案就是可靠消息保证最终一致性, TCC, Seata 等方案了.



在我们的项目中，有多种不同的方案，因为要解决的场景不太一样，目前所有的一致性方案都是围绕着订单来的。

我们主要用了5种一致性方案：

+ RocketMQ事务消息
+ Seata的AT模式
+ TCC
+ 定时任务重试
+ 数据对账 + 人工介入



这4种，其实都是最终一致性的方案，在一致性的保障上，即不一致时长上面：

+ AT是最短的
+ 其次是事务消息
+ 然后的是定时任务的方案
+ 最差的是数据对账 + 人工介入.



在我们项目的订单模块中，需要保证一致性的有三个场景。



+ 场景1：秒杀订单创建
    - 在订单创建的时候，我们会先在redis中做库存的预扣减，然后再操作数据库中的Collection或BlindBox进行库存预扣减，然后再创建订单。
    - 这里要保障的是redis的库存和mysql的库存的一致性，如果出现不一致，会出现少卖的问题。
+ 场景2：订单关单
    - 在订单关单的时候我们要做的事情也很多，首先是把订单关闭，其次是再把库存回滚回去。
    - 这里要保障的是订单系统，库存系统，以及redis库存的一致性，如果不一致，会出现少卖的问题。
+ 场景3：订单支付
    - 在订单支付的时候我们要做的事情也很多，首先是把支付单状态推进，订单状态推进，库存做真正的扣减，生成持有藏品，持有的藏品上链，等等一系列操作。
    - 这里要保证以上这些模块的一致性，要不然数据会缺这少那
+ 场景4：普通交易订单创建
    - 这里普通交易订单创建的时候，我们会先操作数据库中进行库存预扣减，同时创建订单。
    - 这里要保障库存的扣减和订单创建的一致性。



## 秒杀订单创建的一致性方案


在订单创建这个环节，我们首要的目标其实不是一致性，而是可用性，即在CAP中，我们需要保证下单接口，尤其是秒杀过程中的AP而不是CP，这个大家都能理解，因为如果不一致，发生了少卖，影响其实没有那么大，但是如果系统不可用，无法下单，影响更大一点。



所以在订单创建这个过程中，我们一致性的保障其实比较弱，这里会为了提升性能，只把redis的库存扣减放到了同步链路，而把数据库的库存扣减以及订单创建，放到了 异步链路



这里的一致性方案其实就是对账 + 人工介入。

通过在redis中记录库存扣减流水，然后和订单的流水进行核对，发现不一致的情况下，人工介入处理即可。

[[基于Lua+Redis实现库存的秒杀扣减]]


## 订单关单的一致性方案


订单关单这个场景，相比于下单来说，性能要求就没有那么高了，所以可以抽出更多的精力去做一致性保障，减少对账以及人工介入的成本。但是这个环节的一致性要求其实也没特别高，并且只有订单和藏品两个模块交互，那么我们直接使用了事务消息，这里基于RocketMQ的事务消息实现的。

[[基于RocketMQ事务消息实现订单取消的一致性]]


## 支付成功的一致性方案


在一致性的重要程度上来说，订单支付成功的一致性要求更高一点，所以我们引入了Seata，通过AT模式来保证更高的一致性。



之所以选择AT，虽然他也是最终一致性的方案，但是他的一致性要比靠消息更好一点，不一致时间更短一些，而且在订单支付的节点，本来就是外部支付渠道就有消息在驱动，我们再引入一个消息最终一致性整个链路就会有太多的异步，就会很复杂。而且这个环节参与方也比较多，用MQ的话，就需要很多人都监听同一个消息，对代码的侵入性也比较大，处理起来也很麻烦。



而相比Seata的TCC和XA两种模式，AT的侵入性是最低的，并且性能上也能有所保证，所以我们选择了Seata的AT模式来保证这个环节的一致性。

[[基于Seata分布式事务实现支付环节的数据一致性]]


在支付成功的链路上，有一个模块很特殊，那就是区块链模块，我们需要在支付成功后，对本次交易进行上链。



但是因为上链是需要调外部服务的，所以我们没办法把他放到我们的Seata的分布式事务种，因为外部服务不可靠，把他放到事务中可能会导致事务经常回滚。



那么如何保障他和支付成功过程的一致性呢？



这里其实借助了Seata的事务回调以及定时任务来保障的，即我们给seata的全局事务注册一个Hook，在事务commit之后，回调这个hook，然后在这个hook中调链服务进行上链。



这个过程如果失败了，不会对原本的事务造成任何影响，那么我们只需要再引入一个定时任务来重试即可。

[[基于 Seata 的事务钩子+定时任务保障支付成功后上链的一致性]]

## 普通交易订单创建


其实不管是普通交易，还是秒杀交易，订单创建和库存扣减（数据库中）都是需要保证一致性的，但是因为秒杀场景中，库存扣减和订单创建在异步链路中，有重试的，所以基于MQ的这种最终一致性保护的。



但是普通交易是没有MQ的，所以我们需要把他用别的方案来保障，支付这里我们用了AT，这里行不行呢？



其实完全可以引入Seata的AT模式来搞定，但是我们为了讲解TCC，以及TCC中的空回滚，悬挂等问题，这里用了TCC（但是面试的时候，不建议大家说两套不一样的方案，要么都是AT，要么都是TCC）



但是在我们的方案中，没有使用Seata中的TCC，因为我觉得那个方案不好，因为我始终认为，TCC在Try成功之后，confirm大概率都是成功的，所以在confirm之后立即去cancel，虽然提高了一致性，但是也带来了很多回滚，所以我自己实现了一个TCC。

[[引入TCC实现普通交易环节订单和库存的一致性]]
