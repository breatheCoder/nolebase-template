在我们的项目中，有很多并发的场景，但是我们的解决思路是不一样的。这一篇就从整体并发防控的角度来吧这些方案以及为什么用介绍以下。



在并发防控上，其实归根结底就两个方案：

1. 乐观锁
2. 悲观锁



乐观锁主要是以数据库乐观锁为主，就是在表中加一个字段lock_version，每次在操作之前都要比较一下，版本号是否正确。



```sql
UPDATE held_collection  SET name=?, cover=?, purchase_price=?, collection_id=?, serial_no=?, nft_id=?,  user_id=?, state=?, tx_hash=?, hold_time=?, sync_chain_time=?,  biz_type=?, biz_no=?, lock_version=?, gmt_create=?, gmt_modified=?  WHERE id=?   AND lock_version=?  AND deleted=0
```



这里面的update held_collection set lock_version = ? where lock_version = ?就是一个非常经典的用版本号来做乐观锁的控制的场景。



悲观锁的话，因为我们现在的项目都很少单点部署了，所以对于一些资源的管理上synchronized使用频率变低了，因为他只能限制单台JVM的资源，不能够限制分布式场景下，所以由redis实现的分布式锁就是我们实现悲观锁的主要途径。



在这个项目中，我们自己封装了一个注解可以帮我们自动的管理分布式锁，还是很方便的，不用手动lock了，


[[用了_一锁二判三更新_，但是幂等被击穿]]

