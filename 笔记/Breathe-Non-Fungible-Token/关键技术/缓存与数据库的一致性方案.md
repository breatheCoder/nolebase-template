缓存和数据库的一致性的方案，基本业界可用的就三种：



1、先更新数据库，再删除缓存 （我们用了）

2、延迟双删 （我们用了）

3、Cache-Aside，即用 binlog 监听实现缓存更新/删除 （一般大型项目用的比较多）



## 先更新数据库，再删除缓存
对于并发量不太高的项目，直接用第一种就可以，先更新数据库，然后再删除缓存即可。



比如用户信息我们做了缓存，但是在用户状态发生变化的时候，我们需要同时删除缓存，这就是一个典型的先更新数据库，后删除缓存的方案。



```java
public UserOperatorResponse modify(UserModifyRequest userModifyRequest) {
      UserOperatorResponse userOperatorResponse = new UserOperatorResponse();
      User user = userMapper.findById(userModifyRequest.getUserId());
      Assert.notNull(user, () -> new UserException(USER_NOT_EXIST));
      Assert.isTrue(user.canModifyInfo(), () -> new UserException(USER_STATUS_CANT_OPERATE));

      if (StringUtils.isNotBlank(userModifyRequest.getNickName()) && nickNameExist(userModifyRequest.getNickName())) {
          throw new UserException(NICK_NAME_EXIST);
      }
      BeanUtils.copyProperties(userModifyRequest, user);

      if (StringUtils.isNotBlank(userModifyRequest.getPassword())) {
          user.setPasswordHash(DigestUtil.md5Hex(userModifyRequest.getPassword()));
      }
      //更新数据库
      if (updateById(user)) {
          //加入流水
          long streamResult = userOperateStreamService.insertStream(user.getId(), UserOperateTypeEnum.MODIFY);
          Assert.notNull(streamResult, () -> new BizException(RepoErrorCode.UPDATE_FAILED));
          addNickName(userModifyRequest.getNickName());
          userOperatorResponse.setSuccess(true);

          //删除缓存
          telUserCache.remove(user.getTelephone());
          idUserCache.remove(user.getId().toString());

          return userOperatorResponse;
      }
      userOperatorResponse.setSuccess(false);
      userOperatorResponse.setResponseCode(UserErrorCode.USER_OPERATE_FAILED.getCode());
      userOperatorResponse.setResponseCode(UserErrorCode.USER_OPERATE_FAILED.getMessage());

      return userOperatorResponse;
  }
```



因为用户的信息变化并不是特别的频繁，所以其实并发量也不是很高，及时极端情况下出现缓存删除不及时，导致脏读也是可以接受的，所以我们选的是方案1 ，先更新数据库，再删除缓存。



同时，为了避免这种极端的情况下出现的缓存删除失败导致的不一致的情况，我们也做了一些兜底，比如我们在查询处都增加了缓存的自动刷新，到时间之后，缓存也能进行自动更新。



```java
@Cached(name = ":user:cache:id:", expire = 3000, cacheType = CacheType.BOTH, key = "#userId", cacheNullValue = true)
@CacheRefresh(refresh = 60, timeUnit = TimeUnit.MINUTES)
public User findById(Long userId) {
    return userMapper.findById(userId);
}
```



这个方案存在一个问题，那就是万一缓存删除失败了，会导致缓存中一直有脏数据，导致数据不一致。



## 延迟双删
为了减少先更新数据库后删除缓存这个方案存在的不一致问题，我们其实只需要把删除挪到更新数据库之前就行了，这样就能确保更新数据库的时候，缓存一定已经删除了，那么就可以避免脏数据。



但是，这样会带来一个问题，那就是在删除缓存之后，更新数据库之前，另外一个线程如果从数据库中读取了旧值又更新到了缓存中，那么就会导致缓存又变成旧值了。还是会出现不一致的情况了。



所以，解决的方案就是延迟双删，也就是在删除缓存、更新数据库之后，在删除一次缓存。这个的很难掌握的点就是第二次删除的时机不好把握。	



