水平权限漏洞是指web应用接收到用户请求时，没有判断数据的所属人，或者在判断数据所属人时是从用户提交的参数中获取了userid，导致攻击者可以自行修改userid修改不属于自己的数据。



我们的项目中其实提供了很多接口，我们是如何做水平权限控制的呢？



其实我们就做了两件事：



1. 用户ID不相信前端输入的，而是我们自己从session中获取。
2. 用户资产（如订单）操作的时候，进行userId的校验。



那我们的订单支付接口举例。以下是支付接口的部分代码：

```java
@PostMapping("/pay")
public Result<PayOrderVO> pay(@Valid @RequestBody PayParam payParam) {
    String userId = (String) StpUtil.getLoginId();
    SingleResponse<TradeOrderVO> singleResponse = orderFacadeService.getTradeOrder(payParam.getOrderId(), userId);
}
```



从这里可以看到，我们并没有从PayParam中获取userId，而是通过StpUtil从 session 中获取的，获取到的用户 ID一定是当前登录的用户 ID。



并且，使用用户传入的订单号+Session 中取出来的 userId 进行订单查询，如果这订单不存在，或者不是属于这个用户的，那么就会查不到，那么接口就会提示错误，避免了水平越权。只有订单存在并且属于当前登录用户时才能进行支付操作！



并且，我们在OrderManageService 提供了一个hasPermission方法，也是用来控制判断操作权限的。



```java
private boolean hasPermission(TradeOrder existOrder, TradeOrderEvent orderEvent, String operator, UserType operatorType) {
    switch (orderEvent) {
        case PAY:
        case CANCEL:
            return existOrder.getBuyerId().equals(operator);
        case TIME_OUhasPermissionT:
        case CONFIRM:
        case FINISH:
            return operatorType == UserType.PLATFORM;
        default:
            throw new UnsupportedOperationException("unsupport order event : " + orderEvent);
    }
}
```



<font style="color:rgb(38, 38, 38);">这里之所以又做了一遍，主要是因为这个服务是一个基础服务，我们不能完全依赖上游的 Controller 的实现，因为在实际业务中，交易模块和订单模块是两个模块。即使交易模块做了越权校验，但是订单模块也还是要做的，这是一种自我保护的机制。万一上游没做好，我自己还是可以的控住避免出现水平越权的！</font>



