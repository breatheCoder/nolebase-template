在常见的电商中,订单的状态一般有两个入口，



一个是商品详情页，用户立即购买以后，先进行订单的渲染，用户确认价格优惠，收货地址之后，再创建订单。



那如果是订单详情页的入口的话，一般是在订单渲染成功之后，会生成一个唯一的标识。



比如我们的项目中，就是先从后端获取了一个token，然后创单的时候把这个token带进去，后端通过这个token，在redis校验是否存在。



[[基于Token校验避免订单重复提交]]


## 购物车中防重复下单
我们前面说可以通过token来防重复下单，但是这个方案在商品详情页中下单是可以用的，但是在购物车下单就不OK了。



因为前面的方案中，我们说了为了解决用户提前刷token的情况，基于”商品+ 用户“的维度生成token，但是在购物车中是有很多商品的，用户刚进购物车的时候，你也不知道用户要买哪些商品



那怎么办呢？

可以参考淘宝的方案，那就是每一个商品在进入购物车的时候都生成一个cart_item_id。



这个cart_item_id的特点是

1. 全局唯一，所有的用户的cart_item_id都不一样。
2. 只有这个sku在首次进入购物车时才生成，如果是已有sku的加购，无需生成，以为这种情况是直接修改数量。（ Stock Keeping Unit  ）
3. 如果一个商品在购物车中被购买了以后，再次被加入购物车，那就生成一个新的cart_item_id



整个cart_item_id的生成和校验逻辑如下：

![[82fe19c7-0a15-4eeb-a1dc-263244dc082f.svg]]



这种方案其实可以类比本地方法表



通过setnx，借助redis来保证只有一个线程可以成功，因为cart_item_id是全局唯一的，所以能保证某个购物车的

某个商品，只能够被下单一次。



后续这个cart_item_id可以做一个定期清理，或者设置一个失效时间也可以。这个失效时间不用太长，3-5分钟就可以。



上面的方案可以防止用户的误操作，或者秒杀时候的重复点击下单按钮的这种重复下单。

## 疑惑
但是如果发生恶意攻击的话怎么办，会不会有人伪造请求，直接向后端发送下单请求，然后自己伪造一些cart_item_id呢，每次都传不一样的，不久绕开setnx了吗？



并不会，因为cart_item_id和token一样，都是后端生成并发放的，下单携带cart_item_id的时候，我们可以先做一个校验，确保这个cart_item_id是有的，并且是这个用户的购物车中有的才让他下单就行了。

可以存到数据库中，或者像jwt令牌一样，做一个加解密的校验。

