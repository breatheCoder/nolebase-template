- [x] 基于主动 + 被动组合方式实现订单关闭  [completion:: 2025-08-16]

订单创建成功以后, 超过一定时间不支付, 就需要关闭订单, 这里方案有很多, 比如用MQ, 定时任务, Redis等.

我们选择了一种相对轻量并且也比较可靠的方案, 那就是用xxl-job定时任务, 并且为了减少xxl-job关单的延迟问题, 我们同时引入了被动关单的逻辑.

## 被动关单

所谓被动关单, 就是说当用户想要操作这个订单的时候, 我们去检查一下是不是已经超时了, 如果超时了, 并且这个状态还不是关闭的话, 那就执行一次关单操作.

这种被动关单我们在两个地方加了:

1. 用户对订单支付时
2. 用户查看订单详情时

订单支付时关单

用户可以通过订单列表唤起收银台进行支付, 在支付接口中, 我们进行了判断:

```java
/**  
 * 支付  
 *  
 * @param  
 * @return 支付链接地址  
 */  
@PostMapping("/pay")  
public Result<PayOrderVO> pay(@Valid @RequestBody PayParam payParam) {  
    String userId = (String) StpUtil.getLoginId();  
    SingleResponse<TradeOrderVO> singleResponse = orderFacadeService.getTradeOrder(payParam.getOrderId(), userId);  
  
    TradeOrderVO tradeOrderVO = singleResponse.getData();  
  
    if (tradeOrderVO == null) {  
        throw new TradeException(TradeErrorCode.GOODS_NOT_EXIST);  
    }  
  
    if (tradeOrderVO.getOrderState() != TradeOrderState.CONFIRM) {  
        throw new TradeException(TradeErrorCode.ORDER_IS_CANNOT_PAY);  
    }  
  
    if (tradeOrderVO.getTimeout()) {  
        doAsyncTimeoutOrder(tradeOrderVO);  
        throw new TradeException(TradeErrorCode.ORDER_IS_CANNOT_PAY);  
    }  
  
    if (!tradeOrderVO.getBuyerId().equals(userId)) {  
        throw new TradeException(TradeErrorCode.PAY_PERMISSION_DENIED);  
    }  
  
    PayCreateRequest payCreateRequest = new PayCreateRequest();  
    payCreateRequest.setOrderAmount(tradeOrderVO.getOrderAmount());  
    payCreateRequest.setBizNo(tradeOrderVO.getOrderId());  
    payCreateRequest.setBizType(BizOrderType.TRADE_ORDER);  
    payCreateRequest.setMemo(tradeOrderVO.getGoodsName());  
    payCreateRequest.setPayChannel(payParam.getPayChannel());  
    payCreateRequest.setPayerId(tradeOrderVO.getBuyerId());  
    payCreateRequest.setPayerType(tradeOrderVO.getBuyerType());  
    payCreateRequest.setPayeeId(tradeOrderVO.getSellerId());  
    payCreateRequest.setPayeeType(tradeOrderVO.getSellerType());  
  
    PayCreateResponse payCreateResponse = RemoteCallWrapper.call(req -> payFacadeService.generatePayUrl(req), payCreateRequest, "generatePayUrl");  
  
    if (payCreateResponse.getSuccess()) {  
        PayOrderVO payOrderVO = new PayOrderVO();  
        payOrderVO.setPayOrderId(payCreateResponse.getPayOrderId());  
        payOrderVO.setPayUrl(payCreateResponse.getPayUrl());  
        return Result.success(payOrderVO);  
    }  
  
    throw new TradeException(TradeErrorCode.PAY_CREATE_FAILED);  
}
```

这里，针对状态为 CONFIRM 并且已经达到了关单时间的订单，进行一次异步的订单关闭操作。异步关单逻辑如下：

```java
private void doAsyncTimeoutOrder(TradeOrderVO tradeOrderVO) {  
    if (tradeOrderVO.getOrderState() != TradeOrderState.CLOSED) {  
        Thread.ofVirtual().start(() -> {  
            OrderTimeoutRequest cancelRequest = new OrderTimeoutRequest();  
            cancelRequest.setOperatorType(PLATFORM);  
            cancelRequest.setOperator(PLATFORM.getDesc());  
            cancelRequest.setOrderId(tradeOrderVO.getOrderId());  
            cancelRequest.setOperateTime(new Date());  
            cancelRequest.setIdentifier(UUID.randomUUID().toString());  
            orderFacadeService.timeout(cancelRequest);  
        });  
    }  
}
```

这里用了虚拟线程，发起关单操作，这里通过异步实现，不阻塞主线程，主线程直接返回告诉用户订单状态无法支付即可，等他再次刷新时，异步线程执行完了，这个订单也就被关闭了。

用户查看订单详情时关单

除了在列表页的支付发起我们会进行被动关单，还会在用户主动查看订单详情的时候进行这个关单动作。

```java
@GetMapping("/orderDetail")  
public Result<TradeOrderVO> orderDetail(@NotNull String orderId) {  
    String userId = (String) StpUtil.getLoginId();  
    SingleResponse<TradeOrderVO> singleResponse = orderFacadeService.getTradeOrder(orderId, userId);  
    if (singleResponse.getSuccess()) {  
        TradeOrderVO tradeOrderVO = singleResponse.getData();  
        if (tradeOrderVO == null) {  
            return Result.error("ORDER_NOT_EXIST", "订单不存在");  
        }  
        if (tradeOrderVO.getTimeout() && tradeOrderVO.getOrderState() == TradeOrderState.CONFIRM) {  
            //如果订单已经超时，并且尚未关闭，则执行一次关单后再返回数据  
            OrderTimeoutRequest timeoutRequest = new OrderTimeoutRequest();  
            timeoutRequest.setOperatorType(PLATFORM);  
            timeoutRequest.setOperator(PLATFORM.getDesc());  
            timeoutRequest.setOrderId(tradeOrderVO.getOrderId());  
            timeoutRequest.setOperateTime(new Date());  
            timeoutRequest.setIdentifier(UUID.randomUUID().toString());  
            orderFacadeService.timeout(timeoutRequest);  
            singleResponse = orderFacadeService.getTradeOrder(orderId, userId);  
        }  
        return Result.success(singleResponse.getData());  
    } else {  
        return Result.error(singleResponse.getResponseCode(), singleResponse.getResponseMessage());  
    }  
}
```

这里。同样是针对状态为 CONFIRM 并且已经达到了关单时间的订单，进行一次同步的订单关闭操作。

这里为啥就不是异步而是同步了呢？因为这里需要在前台准确的返回最新的订单信息，所以需要同步执行。

## 主动关单

除了以上2个被挡关单的场景, 我们同样定义了定时任务进行定时执行, 进行批量的超时关闭

xxl-job这里也借助了一些特殊的设计, 那就是为了快速扫描分库分表, 我们借助了其分片功能, 详见:

[[基于XXL-JOB的分片实现分库分表后的扫表]]

并且引入了线程池及生产者消费者模式:

[[基于生产者消费者+线程池实现并发关闭订单]]

