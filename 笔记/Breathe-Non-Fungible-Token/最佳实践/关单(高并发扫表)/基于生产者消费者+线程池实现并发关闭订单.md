- [x] 基于生产者消费者+线程池实现并发关闭订单  [completion:: 2025-08-17]

在我们的项目中, 需要通过定时任务来扫描订单表, 进行超时未支付的订单的关单操作.

但是因为我们的表是做了分库分表的, 并且数据量会很大, 单机任务的扫表的性能可能不满足这个要求, 会比较慢, 导致任务堆积.

为了解决这个问题, 我们使用了多线程扫表的方案.

这里基于xxl-job的分片任务, 充分利用集群的所有实例进行任务处理, 并且在每个任务的执行过程中, 采用生产者消费者模式, 在基于线程池进行快速消费.

本文主要介绍生产者消费者 + 线程池, xxl-job的分片见:

[[基于XXL-JOB的分片实现分库分表后的扫表]]

## 生产者消费者

为了让我们的消费速度更快, 我们把从数据库读取数据的动作和消费这些数据的动作拆分开, 分别是生产者和消费者.

生产者从数据库中分页取出数据, 然后把他们放到一个阻塞队列中去, 消费者不断从阻塞队列中取出数据进行消费.

阻塞队列: 在队列为空时, 获取元素的线程, 会等待队列变为非空, 当队列满时, 存储元素的线程会等待队列可用. 阻塞队列常用于生产者消费者的场景, 生产者是往队列里添加元素的线程, 消费者是从队列里拿元素的线程.

```java
int shardIndex = XxlJobHelper.getShardIndex();  
int shardTotal = XxlJobHelper.getShardTotal();  
  
LOG.info("orderTimeOutExecute start to execute , shardIndex is {} , shardTotal is {}", shardIndex, shardTotal);  
  
List<String> buyerIdTailNumberList = new ArrayList<>();  
for (int i = 0; i <= MAX_TAIL_NUMBER; i++) {  
    if (i % shardTotal == shardIndex) {  
        buyerIdTailNumberList.add(StringUtils.leftPad(String.valueOf(i), 2, "0"));  
    }  
}  
  
buyerIdTailNumberList.forEach(buyerIdTailNumber -> {  
    try {  
        List<TradeOrder> tradeOrders = orderReadService.pageQueryTimeoutOrders(PAGE_SIZE, buyerIdTailNumber, null);  
        //其实这里用put更好一点，可以避免因为队列满了而导致异常而提前结束。  
        orderTimeoutBlockingQueue.addAll(tradeOrders);  
        forkJoinPool.execute(this::executeTimeout);  
  
        while (CollectionUtils.isNotEmpty(tradeOrders)) {  
            long maxId = tradeOrders.stream().mapToLong(TradeOrder::getId).max().orElse(Long.MAX_VALUE);  
            tradeOrders = orderReadService.pageQueryTimeoutOrders(PAGE_SIZE, buyerIdTailNumber, maxId + 1);  
            orderTimeoutBlockingQueue.addAll(tradeOrders);  
        }  
    } finally {  
        orderTimeoutBlockingQueue.add(POISON);  
        LOG.debug("POISON added to blocking queue ，buyerIdTailNumber is {}", buyerIdTailNumber);  
    }  
});  
  
return ReturnT.SUCCESS;
```

这里, 在finally中添加了一个毒丸对象POISON, 他只是我们定义的一个空对象, 用来标识生产结束的.

消费者的代码:

```java
private void executeTimeout() {  
    TradeOrder tradeOrder = null;  
    try {  
        while (true) {  
            tradeOrder = orderTimeoutBlockingQueue.take();  
            if (tradeOrder == POISON) {  
                LOG.debug("POISON toked from blocking queue");  
                break;  
            }  
            LOG.info("executeTimeout tradeOrderId = {}", tradeOrder.getId());  
            executeTimeoutSingle(tradeOrder);  
        }  
    } catch (InterruptedException e) {  
        LOG.error("executeTimeout failed", e);  
    }  
    LOG.debug("executeTimeout finish");  
}
```

这里只需要判断从队列中取出来的对象是不是毒丸对象, 如果是, 则跳出循环, 如果不是, 就执行业务逻辑.

这里的生产其实也不是只生产一次, 而是只要数据库还有数据就会不断的向队列中添加的:

```java
@XxlJob("orderTimeOutExecute")  
public ReturnT<String> orderTimeOutExecute() {  
    try {  
        int shardIndex = XxlJobHelper.getShardIndex();  
        int shardTotal = XxlJobHelper.getShardTotal();  
  
        LOG.info("orderTimeOutExecute start to execute , shardIndex is {} , shardTotal is {}", shardIndex, shardTotal);  
  
        List<String> buyerIdTailNumberList = new ArrayList<>();  
        for (int i = 0; i <= MAX_TAIL_NUMBER; i++) {  
            if (i % shardTotal == shardIndex) {  
                buyerIdTailNumberList.add(StringUtils.leftPad(String.valueOf(i), 2, "0"));  
            }  
        }  
        buyerIdTailNumberList.forEach(buyerIdTailNumber -> {  
            try {  
                List<TradeOrder> tradeOrders = orderReadService.pageQueryTimeoutOrders(PAGE_SIZE, buyerIdTailNumber, null);  
                //其实这里用put更好一点，可以避免因为队列满了而导致异常而提前结束。  
                orderTimeoutBlockingQueue.addAll(tradeOrders);  
                forkJoinPool.execute(this::executeTimeout);  
  
                while (CollectionUtils.isNotEmpty(tradeOrders)) {  
                    long maxId = tradeOrders.stream().mapToLong(TradeOrder::getId).max().orElse(Long.MAX_VALUE);  
                    tradeOrders = orderReadService.pageQueryTimeoutOrders(PAGE_SIZE, buyerIdTailNumber, maxId + 1);  
                    orderTimeoutBlockingQueue.addAll(tradeOrders);  
                }  
            } finally {  
                orderTimeoutBlockingQueue.add(POISON);  
                LOG.debug("POISON added to blocking queue ，buyerIdTailNumber is {}", buyerIdTailNumber);  
            }  
        });  
  
        return ReturnT.SUCCESS;  
    } catch (Exception e) {  
        LOG.error("orderTimeOutExecute failed", e);  
        throw e;  
    }  
}
```

## 线程池

这里为了提高消费速度, 我们的消费者是通过多线程进行并发消费的, 从orderTimeoutBlockingQueue中不断的取出任务进行消费.
这里用到了forkjoinpool, 因为我们的消费任务之间是互相独立的任务, forkjoinpool有工作窃取算法, 可以更高效的处理这类任务.

线程池的定义如下:

```java
private final ForkJoinPool forkJoinPool = new ForkJoinPool(10);
```

