我们的订单采用了分库分表，会基于买家ID做分表，同一个买家的订单会路由到同一张分表中。



但是如果我们用订单号查询订单的话，因为没有买家ID这个分表键，就会不知道具体去哪张分表中查询，就需要做全表扫描，把所有的分表都查询一遍。



这样做的效率太差了，于是我们的项目中采用了基因法。



也就是在生成订单号的时候，我们一般会把分表结果编码到订单号中去，因为订单生成的时候是一定可以知道买家ID的，那么我们就把买家ID的路由结果比如1023，作为一段固定的值放到订单号中就行了。这就是所谓的**“基因法”**

****

![[83b0f74e-adaa-4d51-8e77-80fb132226a8.png]]



**这样按订单号查询的时候只需要解析出这段数字，直接去对应的分表查询就可以了。**

****

以下方法，我们的项目中通过一个generateWithSnowflake获取一个订单号，同时需要传入两个参数，一个是businessCode，一个是externalld。



这里的externalld就是我们前面提到的需要用来做分表的买家ID，



generateWithSnowflake会调用generate方法，generate中调用create方法生成一个DistributeID：



```java
/**
 * 利用雪花算法生成一个唯一ID
 */
public static String generateWithSnowflake(BusinessCode businessCode,
                                           String externalId) {
    long id = IdUtil.getSnowflake(businessCode.code()).nextId();
    return generate(businessCode, externalId, id);
}

/**
 * 生成一个唯一ID：10（业务码） 1769649671860822016（sequence) 1023(分表）
 */
public static String generate(BusinessCode businessCode,
                              String externalId, Long sequenceNumber) {
    DistributeID distributeId = create(businessCode, externalId, sequenceNumber);
    return distributeId.businessCode + distributeId.seq + distributeId.table;
}

public static DistributeID create(BusinessCode businessCode,
                                  String externalId, Long sequenceNumber) {

    DistributeID distributeId = new DistributeID();
    distributeId.businessCode = businessCode.getCodeString();
    String table = String.valueOf(shardingTableStrategy.getTable(externalId, businessCode.tableCount()));
    distributeId.table = StringUtils.leftPad(table, 4, "0");
    distributeId.seq = String.valueOf(sequenceNumber);
    return distributeId;
}
```



而create方法中，会基于传入的externalId进行计算，看他到底被分配到哪个具体的单表中：

```java
String table = String.valueOf(shardingTableStrategy.getTable(externalId, businessCode.tableCount()));


public int getTable(String externalId,int tableCount) {
    int hashCode = externalId.hashCode();
    return (int) Math.abs((long) hashCode) % tableCount;
}
```



计算出结果以后，在他前面补零，最终让他变成4位字符，如0001，0002。这样我们的订单号的最后四位就是带分表结果的基因了。



当我们拿订单号查询的时候，直接解析出后四位数字就可以直接路由到指定的表中去做crud了。



具体基于订单号做分片算法的路由，在下面有介绍：



[](undefined)

