
为了保证支付的生成支付链接接口的幂等性，我们通过一锁、二判、三更新进行了严格的幂等控制。

**一锁：第一步，先加锁。可以加分布式锁、或者悲观锁都可以。但是一定要是一个互斥锁！**

**二判：第二步，进行幂等性判断。可以基于状态机、流水表、唯一性索引等等进行重复操作的判断。**

**三更新：第三步，进行数据的更新，将数据进行持久化。**

在我们的项目中实现如下:

```java
@Facade  
@DistributeLock(keyExpression = "#payCreateRequest.bizNo", scene = "GENERATE_PAY_URL")  
@Override  
public PayCreateResponse generatePayUrl(PayCreateRequest payCreateRequest) {  
    PayCreateResponse response = new PayCreateResponse();  
    PayOrder payOrder = payOrderService.create(payCreateRequest);  
  
    if (payOrder.getOrderState() == PayOrderState.PAYING) {  
        response.setPayOrderId(payOrder.getPayOrderId());  
        response.setPayUrl(payOrder.getPayUrl());  
        response.setSuccess(true);  
        return response;  
    }  
  
    if (payOrder.isPaid()) {  
        response.setSuccess(false);  
        response.setResponseCode(PayErrorCode.ORDER_IS_ALREADY_PAID.getCode());  
        response.setResponseMessage(PayErrorCode.ORDER_IS_ALREADY_PAID.getMessage());  
        return response;  
    }  
  
    PayChannelResponse payChannelResponse = doPay(payCreateRequest, payOrder);  
  
    if (payChannelResponse.getSuccess()) {  
        boolean updateResult = payOrderService.paying(payOrder.getPayOrderId(), payChannelResponse.getPayUrl());  
        Assert.isTrue(updateResult, () -> new BizException(RepoErrorCode.UPDATE_FAILED));  
        response.setSuccess(true);  
        response.setPayOrderId(payOrder.getPayOrderId());  
        response.setPayUrl(payChannelResponse.getPayUrl());  
    } else {  
        response.setSuccess(false);  
        response.setResponseCode(payChannelResponse.getResponseCode());  
        response.setResponseMessage(payChannelResponse.getResponseMessage());  
    }  
    return response;  
}
```

**一锁**：通过@DistributeLock自定义注解实现在方法入口处进行加锁，锁的内容是业务单号，确保同一个业务单号同一时刻只能有一次生成付款单的请求过来。

**二判**：这个逻辑在PayOrderService.create方法中，我们一进来就根据业务单号、付款方、以及支付渠道进行数据库查询，判断是否已存在在途的支付单，如果存在，则直接返回已有的支付单上的支付链接给到前端。

**三更新**：如果第二步判断的结果是数据库中不存在在途的支付单，则重新创建一个新的支付单，并且调用具体的渠道方生成一个支付链接，将链接更新到数据库中之后，返回给前端。

