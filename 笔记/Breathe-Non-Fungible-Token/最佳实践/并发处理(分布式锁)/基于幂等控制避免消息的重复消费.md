在分布式系统中，幂等性是指对相同操作执行多次，结果应该是相同的.

在消息传递系统中，我们需要确保消息的消费是幂等的，以避免重复消费带来的问题。

通常通过消息体中带入幂等号，然后再消息消费的时候对该幂等号进行校验，来控制并避免消息的重复消费.

## 步骤

拿订单模块的消息取消来举例

### 1. 设置消息体

```java
@Getter  
@Setter  
public class OrderCancelRequest extends BaseOrderUpdateRequest {  
  
    @Override  
    public TradeOrderEvent getOrderEvent() {  
        return TradeOrderEvent.CANCEL;  
    }  
}
```

```java
@Setter  
@Getter  
public abstract class BaseOrderUpdateRequest extends BaseOrderRequest {  
  
    /**  
     * 订单id  
     */    @NotNull(message = "orderId 不能为空")  
    private String orderId;  
  
    /**  
     * 操作时间  
     */  
    @NotNull(message = "operateTime 不能为空")  
    private Date operateTime;  
  
    /**  
     * 操作人  
     */  
    @NotNull(message = "operator 不能为空")  
    private String operator;  
  
    /**  
     * 操作人类型  
     */  
    @NotNull(message = "operatorType 不能为空")  
    private UserType operatorType;  
}
```

```java
@Getter  
@Setter  
public abstract class BaseOrderRequest extends BaseRequest {  
  
    /**  
     * 操作幂等号  
     */  
    @NotNull(message = "identifier 不能为空")  
    private String identifier;  
  
    /**  
     * 获取订单事件  
     *  
     * @return  
     */  
    public abstract TradeOrderEvent getOrderEvent();  
}
```

可以看到在BaseOrderRequest里面有identifier和orderEvent这两个参数，通过这两个参数来定义对订单的一次操作的幂等，对于为什么一个消息体需要定义成这几个类，这个是基于业务的抽象，把一些共有的属性往上层抽，便于复用

### 2. 新增订单操作的流水

![[Pasted image 20250816145046.png]]

该表是基于订单进行修改，新增stream_identifier和stream_type两个字段

### 3. 消息配置

```yaml
spring: 
	cloud: 
		function: 
			definition: orderClose;heldCollection 
		stream: 
			rocketmq: 
				bindings: 
					orderClose-out-0: 
						producer: 
							producerType: Trans 
							transactionListener: orderCloseTransactionListener 
					heldCollection-in-0:
						consumer: 
							subscription: 
								expression: 'ACTIVE' # 这里设置你希望订阅的Tag
				bindings: 
					heldCollection-in-0: 
						content-type: application/json 
						destination: held-collection-result-topic 
						group: held-collection-group 
						binder: rocketmq 
					orderClose-out-0: 
						content-type: application/json 
						destination: order-close-topic 
						group: order-group 
						binder: rocketmq
```

这里绑定了orderClose-out-0，有消息过来会触发orderCloseTransactionListener进行处理

### 4. 消息处理通过流水进行幂等控制

```java
@Component  
public class OrderCloseTransactionListener implements TransactionListener {  
  
    private static final Logger logger = LoggerFactory.getLogger(OrderCloseTransactionListener.class);  
  
    @Autowired  
    private OrderManageService orderManageService;  
  
    @Autowired  
    private OrderReadService orderReadService;  
  
    @Override  
    public LocalTransactionState executeLocalTransaction(Message message, Object o) {  
        try {  
            Map<String, String> headers = message.getProperties();  
            String closeType = headers.get("CLOSE_TYPE");  
  
            OrderResponse response = null;  
            if (TradeOrderEvent.CANCEL.name().equals(closeType)) {  
                OrderCancelRequest cancelRequest = JSON.parseObject(JSON.parseObject(message.getBody()).getString("body"), OrderCancelRequest.class);  
                logger.info("executeLocalTransaction , baseOrderUpdateRequest = {} , closeType = {}", JSON.toJSONString(cancelRequest), closeType);  
                response = orderManageService.cancel(cancelRequest);  
            } else if (TradeOrderEvent.TIME_OUT.name().equals(closeType)) {  
                OrderTimeoutRequest timeoutRequest = JSON.parseObject(JSON.parseObject(message.getBody()).getString("body"), OrderTimeoutRequest.class);  
                logger.info("executeLocalTransaction , baseOrderUpdateRequest = {} , closeType = {}", JSON.toJSONString(timeoutRequest), closeType);  
                response = orderManageService.timeout(timeoutRequest);  
            } else {  
                throw new UnsupportedOperationException("unsupported closeType " + closeType);  
            }  
  
            if (response.getSuccess()) {  
                return LocalTransactionState.COMMIT_MESSAGE;  
            } else {  
                return LocalTransactionState.ROLLBACK_MESSAGE;  
            }  
        } catch (Exception e) {  
            logger.error("executeLocalTransaction error, message = {}", message, e);  
            return LocalTransactionState.ROLLBACK_MESSAGE;  
        }  
    }  
    @Override  
    public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {  
        String closeType = messageExt.getProperties().get("CLOSE_TYPE");  
        BaseOrderUpdateRequest baseOrderUpdateRequest = null;  
        if (TradeOrderEvent.CANCEL.name().equals(closeType)) {  
            baseOrderUpdateRequest = JSON.parseObject(JSON.parseObject(new String(messageExt.getBody())).getString("body"), OrderCancelRequest.class);  
        } else if (TradeOrderEvent.TIME_OUT.name().equals(closeType)) {  
            baseOrderUpdateRequest = JSON.parseObject(JSON.parseObject(new String(messageExt.getBody())).getString("body"), OrderTimeoutRequest.class);  
        }  
  
        TradeOrder tradeOrder = orderReadService.getOrder(baseOrderUpdateRequest.getOrderId());  
  
        if (tradeOrder.getOrderState() == TradeOrderState.CLOSED) {  
            return LocalTransactionState.COMMIT_MESSAGE;  
        }  
  
        return LocalTransactionState.ROLLBACK_MESSAGE;  
    }  
}
```

如果是cancel的消息，会通过下面的代码块进行处理

```java
if (TradeOrderEvent.CANCEL.name().equals(closeType)) {  
    OrderCancelRequest cancelRequest = JSON.parseObject(JSON.parseObject(message.getBody()).getString("body"), OrderCancelRequest.class);  
    logger.info("executeLocalTransaction , baseOrderUpdateRequest = {} , closeType = {}", JSON.toJSONString(cancelRequest), closeType);  
    response = orderManageService.cancel(cancelRequest);  
}
```

其中cancel的核心逻辑

```java
/**  
 * 订单取消  
 *  
 * @param request  
 * @return  
 */  
public OrderResponse cancel(OrderCancelRequest request) {  
    return doExecute(request, tradeOrder -> tradeOrder.close(request));  
}
```

会调用通用的订单处理逻辑

```java
/**  
 * 通用订单更新逻辑  
 *  
 * @param orderRequest  
 * @param consumer  
 * @return  
 */  
protected OrderResponse doExecute(BaseOrderUpdateRequest orderRequest, Consumer<TradeOrder> consumer) {  
    OrderResponse response = new OrderResponse();  
    return handle(orderRequest, response, "doExecute", request -> {  
  
        TradeOrder existOrder = orderMapper.selectByOrderId(request.getOrderId());  
        if (existOrder == null) {  
            throw new OrderException(ORDER_NOT_EXIST);  
        }  
  
        if (!hasPermission(existOrder, orderRequest.getOrderEvent(), orderRequest.getOperator(), orderRequest.getOperatorType())) {  
            throw new OrderException(PERMISSION_DENIED);  
        }  
  
        TradeOrderStream existStream = orderStreamMapper.selectByIdentifier(orderRequest.getIdentifier(), orderRequest.getOrderEvent().name(), orderRequest.getOrderId());  
        if (existStream != null) {  
            return new OrderResponse.OrderResponseBuilder().orderId(existStream.getOrderId()).streamId(existStream.getId().toString()).buildDuplicated();  
        }  
  
        //核心逻辑执行  
        consumer.accept(existOrder);  
  
        //开启事务  
        return transactionTemplate.execute(transactionStatus -> {  
  
            boolean result = orderMapper.updateByOrderId(existOrder) == 1;  
            Assert.isTrue(result, () -> new OrderException(OrderErrorCode.UPDATE_ORDER_FAILED));  
  
            TradeOrderStream orderStream = new TradeOrderStream(existOrder, orderRequest.getOrderEvent(), orderRequest.getIdentifier());  
            result = orderStreamMapper.insert(orderStream) == 1;  
            Assert.isTrue(result, () -> new BizException(RepoErrorCode.INSERT_FAILED));  
  
            return new OrderResponse.OrderResponseBuilder().orderId(orderStream.getOrderId()).streamId(String.valueOf(orderStream.getId())).buildSuccess();  
        });  
    });  
}
```

可以看到通过幂等号和orderEvent进行了幂等控制