[[基于Redis的ZSET实现用户邀请排行榜]]

前面的实现中, 如果分数相同, 那么排序结果是不确定的, 那么如果我们想要实现多维度排名, 即先按分数排, 分数相同的话再按上榜时间排序, 如何实现呢?

为了实现分数相同按时间顺序排序, 我们可以讲分数score设置为一个浮点数, 其中整数部分为得分, 小数部分为时间戳.

score = 分数 + 时间戳 / 1e13

假设现在时间戳是1680417299000, 除以1e13得到0.16....., 再加上一个固定的分数, 比如10, 那么最终的得分就是10.16......, 可以将他作为ZSET的成员的score用来排序.

这么做之后, 假如说有4个数字:

10.1680417299000、10.1680417299011、11.1680417299000、11.1680417299011

他们排完序的结果是确定的.

11.1680417299011>11.1680417299000>10.1680417299011>10.1680417299000

实现了分数倒序排列，分数相同时间戳大（上榜更晚的）的排在了前面，这和我们的需求相反了，所以，就需要在做一次转换。(其实就是用1 - 这个小数就可以了)

这样可以保证分数相同时，按照时间戳从小到大排序，即先得分的先被排在前面。

```java
//获取最近一次上榜时间  
long currentTimeStamp = System.currentTimeMillis();  
//把上榜时间转成小数(时间戳13位，所以除以10000000000000能转成小数)，并且倒序排列（用1减），即上榜时间越早，分数越大（时间越晚，时间戳越大，用1减一下，就反过来了）  
double timePartScore = 1 - (double) currentTimeStamp / 10000000000000L;  
  
//1、当前积分保留整数，即移除上一次的小数位  
//2、当前积分加100，表示新邀请了一个用户  
//3、加上“最近一次上榜时间的倒序小数位“作为score  
inviteRank.add(score.intValue() + 100.0 + timePartScore, inviterId);
```

