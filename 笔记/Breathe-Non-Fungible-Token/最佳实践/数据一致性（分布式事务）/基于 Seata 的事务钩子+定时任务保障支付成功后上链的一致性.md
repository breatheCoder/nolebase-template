在我们的项目中，在订单完成支付后，我们会接受到外部支付渠道的支付成功消息。接收到消息之后需要做以下事情：



```latex
1、查询订单状态
2、推进订单状态到支付成功
3、藏品库存真正扣减
4、创建持有的藏品
5、推进支付状态到支付成功
6、持有的藏品上链
```



为了保证1-5的一致性，我们用了seata的at模式来保证他们在同一个事务中，保证可以要么都提交，要么都回滚。



但是第六步，我们并没有放到分布式事务中，原因是什么？不放到事务中如何保证一致性？



## 为什么不放到事务中


主要是因为上链这个操作，我们需要依赖外部第三方的链平台。这里面就需要有网络交互，并且要依赖外部的可用性。



一旦出现网络延迟，中断，或者外部平台的不可用，就可能导致整个事务回滚，更重要的是，即使我们做了分布式事务，用了AT模式，但是外部平台是无法回滚的，只有我们自己的数据库才能一起回滚。



这就是说不仅会使得事务异常的回滚概率增大，并且还会带来不一致的问题，所以我们不能把上链这个操作放到事务中。



当然，我们可以把上链拆成2个步骤，第一步先存到chain的数据库中，然后再异步任务轮询调用。也可以，但是这样就会存在一定的延迟问题。



所以我们没用这个方案，而是换了个方案。

## 如何保证一致性


为了保证这6步能够保持一致，那么我们看一下前5步的结果。



其实对于前5步来说，他们在一个事务中，那么最终的结果要么是commit，要么是rollback。



针对前5步的rollback，那么第6步什么都不需要做。



针对前5步的commit，第6步需要确保可以成功。



基于以上的思考，如果我们能在前5步commit之后，出发第6步的执行，并且想办法保证他一定能成功就行了，

这时候就在想有没有一个类似于spring中管理bean的生命周期的接口，通过查阅资料，果然是有的，在seata中有一个TransactionHook，这是一个事务回调钩子，它可以在事务的commit，rollback操作前后，执行特定的操作，回调对应的方法。



那么我们就注册一个commit的hook，这样当seata事务提交的时候，就可以回调我们的aftercommit方法，我们在aftercommit方法中上链。



当然，调链服务，或者上链操作，有可能也会失败，只不过这种失败的概率比较低，我们只需要引入一个定时任务做对失败任务的重试就好了。



而且即使aftercommit方法中执行失败了，也不影响事务本身的执行。



这样既能减少异常导致事务回滚的概率，也能降低不一致的概率和时长，这其实就是一种典型的同步转异步的做法。



> 就是说同步先干一把，如果失败了，再异步重试。
>



实现方法就是我们在paySuccess的全局事务中，注册一个回调，（TransactionHookManager）

![[2263f9f9-4175-4a6e-8a47-aab401c3aafb.png]]



![[98c5f6f1-f32c-4c34-b809-b9249e36b719.png]]



