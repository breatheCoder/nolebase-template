在很多秒杀场景中 ，用户为了能够下单成功，会频繁的点击下单按钮，这时候如果没有做好控制的话，就可能给一个用户创建重复的订单。



那么我们如何防止这个问题呢？



其实有一个好办法，那就是在用户下单的时候带一个token过来，然后后端来校验一下这个token 的有效性，如果该token有效，则允许下单，如果无效，就不允许用户下单。



> 注意：这里的token和用户登录的token不同，只是名字相同，这里的token可以将他当作一个唯一性标识，每一次请求都会生成一个。我们自己实现他的发放和校验和删除。
>



![[8f75206c-d463-4eb7-964c-3b9346513cde.svg]]



那么这个token是如何发放和校验的呢？



token的发放比较简单，我们定义了一个controller，在下单页面渲染的时候，从接口中获取一下就可以了。



![[eb70c085-72f6-4153-85b5-b71dfd07a2c1.png]]



以上就是一个token的获取过程，通过用户传入的scene，满足在不同的场景下使用token，并把它存储在redis中，返回给前端。



前端在获取到这个token后，需要在下单接口把这个token带过来，然后我们在后端判断一下，他的有效性，token的校验我们是通过filter实现的，这样做会更加的通用一点。



![[148e6944-dc5f-4feb-bc96-009dcc01004f.png]]



主要实现在doFilter方法中，主要是判断请求是否携带了token，如果携带了，通过redis校验token是否有效，如果有效，将redis中的token删掉，然后返回true，放过请求，如果无效，直接拒绝请求。



这里的token的校验以及移除，我们是通过lua脚本做的，保证原子性。



有了这个filter之后，我们需要让他能够生效，则需要以下配置：

![[d06d4d47-d384-4db9-8c09-a20ebcb8406d.png]]

这里，我们并不需要给所有的接口加token校验，其实很多接口是不需要的，所以我们只需要通过registrationBean.addUrlPatterns()添加我们需要的路径就可以了



## token太多了
恶意请求不停的获取token，我们如何解决呢？

[[秒杀场景下，大量请求同时获取token，如何应对？]]


