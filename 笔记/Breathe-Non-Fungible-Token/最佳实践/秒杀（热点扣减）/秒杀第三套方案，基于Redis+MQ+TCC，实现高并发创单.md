[[秒杀第二套方案：基于Redis+MQ+数据库实现高并发扣减]]

上面是我们项目的第二套方案, 基于redis + MQ + 数据库 实现高并发处理.

整体流程和下面一样的, 同步链路扣减redis库存, 然后发MQ, 再去异步扣减数据库中的库存.

![[Pasted image 20250815110545.png]]

上面方案有一个细节, 那就是订单其实是在异步链路创建的, 即在接收到MQ之后, 先扣减库存, 然后再创建订单的, 之所以要那么做的话, 主要是为了避免超卖以及保证订单和库存之间的一致性:

[[为什么第二套秒杀方案中, 订单的创建要放到异步链路]]

但是这个方案也有一个很关键的缺点, 那就是存在性能瓶颈, 因为我们的订单创建是在库存扣减之后的, 而库存扣减在高并发情况下是一个数据库的热点操作, 热点操作就会导致执行存在延迟的情况, 经过我们的压测发现, 在并发数达到300的情况下, redis的库存和数据库的库存扣减之间的延迟会达到11-12s的延迟!!!

那么也就意味着, 当并发数达到300的时候, 用户需要在页面上等11-12s, 这对用户的体验太不友好了

那么, 既然瓶颈在数据库的扣减的热点更新上, 而我们的需求是订单的创建不要有那么大的延迟, 那么我们就做些调整, 把订单的创建从异步链路改为同步链路.

方案二 VS 方案三

![[Pasted image 20250815112243.png]]

方案三大图如下:

![[Pasted image 20250815112341.png]]

想实现这个方案, 其实改造也很简单, 只需要在调完redis占完库存以后, 再调一把订单创建,然后发消息就可以了.

但是如果是这样的话, 会出现一个问题:

**redis库存扣减成功, 但是订单创建失败了, 怎么办?**

方案一: 直接回滚redis的扣减库存
- redis不支持回滚操作, 可以通过调用库存增加的方法, 再把库存加上去.
- 但是有个关键问题, 那就是如果因为网络超时, 导致订单创建抛出了异常, 但是实际上订单已经创建成功了, 这时候如果回滚库存会导致超卖.
- 那么可行的方案就是: 如果因为订单创建抛了异常, 这时候检查一下订单的状态, 如果成功了, 则不回退库存, 失败了就回退库存.

方案二: 失败就失败了, 直接不管
- 这种肯定不行, 会导致订单和库存不一致, 库存扣减了, 但是订单没创建, 就会出现少卖的情况.

那么现在的逻辑是:

1. 调用redis占用库存
2. 调订单创建
3. 如果订单创建成功, 返回订单号, 让用户支付.
4. 如果订单创建失败或者异常, 反查订单
5. 如果订单已经有了, 则返回订单号, 让用户支付.
6. 如果订单没有, 则回退redis的库存.


这时候有一个时机就比较重要了, 我们的查询操作和订单的创建操作快怎么办, 订单正在创建, 我们没查到, 直接去回滚redis的库存

> 比如订单创建正要执行，GC发生了，STW了，上游发现订单创建超时了，发起查询订单，这时候STW结束了，查询订单的线程拿到了CPU执行查询，发现订单没创建，这时候上游发现没有订单，就把库存加回去了，可是创建订单的线程继续拿到CPU后执行，把订单给创建了，还是出现了不一致。虽然概率比较低。

所以好一点的做法是这里做一个延迟查询订单, 就这个方案, 我们定义了一个newBuyPlus方法

![[Pasted image 20250815113411.png]]

本地事务的执行在OrderCreateTransactionListener：

![[Pasted image 20250815113423.png]]

TradeApplicationService的newBuyPlus中的TCC逻辑如下：

![[Pasted image 20250815113433.png]]

这里的库存回滚是异步执行的，具体原因可以参考：

[[为什么cancel的时候不同步执行, 要通过消息驱动]]

NewBuyPlusMsgListener中进行废单和疑似废单消息的处理逻辑：

![[Pasted image 20250815120315.png]]