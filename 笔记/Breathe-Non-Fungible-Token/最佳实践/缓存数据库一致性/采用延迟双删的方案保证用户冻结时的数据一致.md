延迟双删是一种解决缓存与数据库双写一致性的方案，核心目的是在数据库更新后尽可能减少缓存中的脏数据，保证数据一致性。其核心步骤是：



1. 第一次删除：在更新数据库前，先删除缓存。
2. 更新数据库，执行数据库的写操作。
3. 延迟等待：等待一段时间（通常位主从同步延迟时间 + 少量缓冲时间）。
4. 第二次删除：再次删除缓存。



**第一次删除的目的是为了**清除缓存旧值，强制后续读请求直接访问数据库（避免直接返回旧缓存）。



**第二次删除（延迟后）的目的是为了**清除在数据库更新期间可能被其他请求写入的旧缓存值。



延迟双删这种方案我们也用了，主要是为了避免一次删除缓存导致的缓存删除失败出现的不一致问题，我们在用户模块中同样做了延迟双删的方案设计。



那就是在我们的用户的冻结、解冻接口中，我们做了延迟双删，因为对于冻结、解冻接口来说，虽然并发量不高，但是对于不一致的接受度比较低，我们希望能快速的更新缓存，避免不一致。所以引入了延迟双删。



为了减少缓存的不一致，我们其实只需要把删除挪到更新数据库之前就行了，这样就能确保更新数据库的时候，缓存一定已经删除了，那么就可以避免脏数据。



但是，这样会带来一个问题，那就是在删除缓存之后，更新数据库之前，另外一个线程如果从数据库中读取了旧值又更新到了缓存中，那么就会导致缓存又变成旧值了。还是会出现不一致的情况了。



所以，解决的方案就是延迟双删，也就是在删除缓存、更新数据库之后，在删除一次缓存。如我们的冻结接口：



```java
@Transactional(rollbackFor = Exception.class)
public UserOperatorResponse freeze(Long userId) {
    UserOperatorResponse userOperatorResponse = new UserOperatorResponse();
    User user = userMapper.findById(userId);
    Assert.notNull(user, () -> new UserException(USER_NOT_EXIST));
    Assert.isTrue(user.getState() == UserStateEnum.ACTIVE, () -> new UserException(USER_STATUS_IS_NOT_ACTIVE));

    //第一次删除缓存
    telUserCache.remove(user.getTelephone());
    idUserCache.remove(user.getId().toString());

    if (user.getState() == UserStateEnum.FROZEN) {
        userOperatorResponse.setSuccess(true);
        return userOperatorResponse;
    }
    //更新数据库
    user.setState(UserStateEnum.FROZEN);
    boolean updateResult = updateById(user);
    Assert.isTrue(updateResult, () -> new BizException(RepoErrorCode.UPDATE_FAILED));
    //加入流水
    long result = userOperateStreamService.insertStream(userId, UserOperateTypeEnum.FREEZE);
    Assert.notNull(result, () -> new BizException(RepoErrorCode.UPDATE_FAILED));

    //第二次删除缓存
    userCacheDelayDeleteService.delayedCacheDelete(telUserCache, idUserCache, user);

    userOperatorResponse.setSuccess(true);
    return userOperatorResponse;
}
```



这里，我们在更新数据库之前先删除了一次缓存。在更新数据库之后借助userCacheDelayDeleteService进行了一次延迟双删。



delayedCacheDelete其实就是一个延迟任务，延迟2秒钟再清空一次缓存，避免出现不一致的情况。



```java
@Service
@Slf4j
public class UserCacheDelayDeleteService {

    private static ThreadFactory userCacheDelayProcessFactory = new ThreadFactoryBuilder()
            .setNameFormat("user-cache-delay-delete-pool-%d").build();

    private ScheduledExecutorService scheduler = new ScheduledThreadPoolExecutor(10, userCacheDelayProcessFactory);

    public void delayedCacheDelete(Cache idUserCache, User user) {
        scheduler.schedule(() -> {
            boolean idDeleteResult = idUserCache.remove(user.getId().toString());
            log.info("idUserCache removed, key = {} , result  = {}", user.getId(), idDeleteResult);
        }, 2, TimeUnit.SECONDS);
    }
}

```



这里面用了schedule(Runnable command, long delay, TimeUnit unit);进行调度，其中制定depay=2，unit=SECONDS，表示延迟2分钟执行。

