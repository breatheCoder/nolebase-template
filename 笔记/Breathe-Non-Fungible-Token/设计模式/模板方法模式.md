模板方法模式是一种在软件工程中用来定义程序框架的设计模式，它通过把不变的行为搬移到超类，去除子类中的重复代码来体现软件工程的"不要重复你自己"（DRY）的原则。

模板方法模式通常涉及一个抽象类，该抽象类声明了一系列的步骤用以执行一个算法。具体子类可以重写算法实现的某些步骤而不改变算法的结构，即"模板"的框架。重点在于，模板（即算法的框架）已经在父类中定义好，子类的实现只需关注那些可变或必须被自定义的步骤。

## 示例

```java
protected ChainProcessResponse doPostExecute(ChainProcessRequest chainProcessRequest, ChainOperateTypeEnum chainOperateTypeEnum,  
                                             Consumer<ChainRequest> consumer) {  
    return handle(chainProcessRequest, request -> {  
        Boolean rateLimitResult = slidingWindowRateLimiter.tryAcquire(  
                "limit#" + chainProcessRequest.getBizType() + chainProcessRequest.getIdentifier(), 1, 60);  
        if (!rateLimitResult) {  
            return new ChainProcessResponse.Builder().responseCode(ChainCodeEnum.PROCESSING.name()).data(  
                    new ChainOperationData(chainProcessRequest.getIdentifier())).buildSuccess();  
        }  
        ChainOperateInfo chainOperateInfo = chainOperateInfoService.queryByOutBizId(chainProcessRequest.getBizId(), chainProcessRequest.getBizType(),  
                chainProcessRequest.getIdentifier());  
        if (null != chainOperateInfo) {  
            return duplicateResponse(chainProcessRequest, chainOperateTypeEnum, chainOperateInfo);  
        }  
  
        ChainRequest chainRequest = new ChainRequest();  
  
        var operateInfoId = chainOperateInfoService.insertInfo(chainType(),  
                chainProcessRequest.getBizId(), chainProcessRequest.getBizType(), chainOperateTypeEnum.name(),  
                JSON.toJSONString(chainProcessRequest), chainProcessRequest.getIdentifier());  
        //核心逻辑执行  
        consumer.accept(chainRequest);  
  
        ChainResponse result = doPost(chainRequest);  
        log.info("wen chang post result:{}", JSON.toJSONString(result));  
  
        boolean updateResult = chainOperateInfoService.updateResult(operateInfoId, null,  
                result.getSuccess() ? result.getData().toString() : result.getError().toString());  
  
        if (!updateResult) {  
            throw new SystemException(RepoErrorCode.UPDATE_FAILED);  
        }  
  
        ChainProcessResponse response = buildResult(result, chainProcessRequest, chainOperateTypeEnum);  
        if (response.getSuccess() && chainOperateTypeEnum != ChainOperateTypeEnum.USER_CREATE) {  
            //延迟5秒钟之后查询状态并发送 MQ 消息通知上游  
            scheduler.schedule(() -> {  
                try {  
                    ChainOperateInfo operateInfo = chainOperateInfoService.queryByOutBizId(chainProcessRequest.getBizId(), chainProcessRequest.getBizType(),  
                            chainProcessRequest.getIdentifier());  
                    ChainProcessResponse<ChainResultData> queryChainResult = queryChainResult(  
                            new ChainQueryRequest(chainProcessRequest.getIdentifier(), operateInfoId.toString()));  
                    if (queryChainResult.getSuccess() && queryChainResult.getData() != null) {  
                        if (StringUtils.equals(queryChainResult.getData().getState(), ChainOperateStateEnum.SUCCEED.name())) {  
                            this.sendMsg(operateInfo, queryChainResult.getData());  
  
                            chainOperateInfoService.updateResult(operateInfoId,  
                                    ChainOperateStateEnum.SUCCEED, null);  
                        }  
                    }                } catch (Exception e) {  
                    log.error("query chain result failed,", e);  
                }  
            }, 5, TimeUnit.SECONDS);  
        }  
  
        return response;  
    });  
}
```

在这个方法实现上, 我们提供了一个固定的操作(模板), 在其中插入特定的自定义行为.

该方法执行以下特定的操作流程:

1. 流量控制: 首先, 尝试通过slidingWindowRateLimiter获取执行权限. 如果获取失败(表示达到流量上限), 则返回一个标记为"处理中"的响应.
2. 查询操作信息: 查询与请求标识符相关的操作信息, 如果找到了对应的操作结果, 并且业务类型是用户创建, 则解析结果并返回, 否则也返回一个处理中的响应.
3. 构建ChainRequest并执行: 如果没有找到对应的操作结果, 就构建一个新的chainRequest对象, 并执行特定的业务逻辑. 这个业务逻辑通过Consumer<`ChainRequest`> consumer参数传入，它代表了外部定义的、可自定义的具体执行步骤。
4. 处理结果：最后，通过doPost方法处理chainRequest，并通过buildResult方法构建最终的响应对象.

这个方法的模板在于: 他定义了处理链式请求的基本步骤, 这些步骤构成了处理请求的固定框架. 而通过Consumer<`ChainRequest`> consumer参数，调用者可以插入自定义的处理逻辑，在这个固定框架中执行特定的操作。这种结构允许调用者在不改变基本处理流程的前提下，处理各种链式请求的不同需求，体现了模板方法模式的“个性化定制步骤”的精神。

这种设计确实利用了模板方法模式的核心理念：定义算法的框架，并允许子类或用户代码在不改变框架的情况下添加或修改某些步骤的实现。在这个示例中，通过委托（Consumer<`ChainRequest`>）实现了这种灵活性。