为了让我们的消费速度更快，我们把从数据库读取数据的动作和消费这些数据的动作拆分开，分别是生产者和消费者。

生产者从数据库中分页取出数据，然后把他们放到一个阻塞队列中，消费者不断从阻塞队列中取出数据进行消费。

阻塞队列：在队列为空时，获取元素的线程会等待队列变为非空。 当队列满时，存储元素的线程会等待队列可用。 阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。

```java
try{
    buyerIdTailNumberList.forEach(buyerIdTailNumber -> {
        int currentPage = 1;
        Page<TradeOrder> page = orderReadService.pageQueryTimeoutOrders(currentPage, PAGE_SIZE, buyerIdTailNumber);
        //生产
        orderTimeoutBlockingQueue.addAll(page.getRecords());
        //消费
        forkJoinPool.execute(this::executeTimeout);
    });
}finally {
    //添加毒丸
    orderTimeoutBlockingQueue.add(POISON);
    LOG.info("POISON added to blocking queue");
}
```

这里，在 finally 中添加了一个毒丸对象`POISON`，他只是我们的定义的一个空对象，用来标识生产结束的。

消费者的代码如下：

```java
private void executeTimeout() {
    TradeOrder tradeOrder = null;
    try {
        while (true){
            tradeOrder = orderTimeoutBlockingQueue.take();
            if (tradeOrder == POISON) {
                break;
            }
            executeTimeoutSingle(tradeOrder);
        }
    } catch (InterruptedException e) {
        LOG.error("executeTimeout failed", e);
    }
}
```

这里只需要判断从队列中取出来的对象是不是毒丸对象，如果是，则跳出循环，任务结束，如果不是，则执行业务逻辑。

这里的生产其实也并不是只生产一次，而是只要数据库中还有数据就会不断向队列中添加的：

```java
try{
    buyerIdTailNumberList.forEach(buyerIdTailNumber -> {
        int currentPage = 1;
        Page<TradeOrder> page = orderReadService.pageQueryTimeoutOrders(currentPage, PAGE_SIZE, buyerIdTailNumber);
        orderTimeoutBlockingQueue.addAll(page.getRecords());
        forkJoinPool.execute(this::executeTimeout);

        while (page.hasNext()) {
            currentPage++;
            page = orderReadService.pageQueryTimeoutOrders(currentPage, PAGE_SIZE, buyerIdTailNumber);
            orderTimeoutBlockingQueue.addAll(page.getRecords());
        }
    });
}finally {
    orderTimeoutBlockingQueue.add(POISON);
    LOG.info("POISON added to blocking queue");
}
```