在我们的项目中有很多地方都会去为了避免并发，增加分布式锁，并且会采用一锁，二判，三更新的方式实现一个幂等逻辑。



同时为了方便大家使用分布式锁，我们自己定义了一个@DistributeLock的注解，也是就有以下代码

![[c4aa2dba-91d1-48d0-9e5d-5995d22533db.png]]

同一个方法，增加了多个注解，同时又@DistributeLock和@Transactional两个注解。



这种情况在，我们自定义的@DistributeLock默认会最后执行，于是这段代码就会先执行事务，然后再执行加锁。



最终的逻辑就像这个代码一样

```java
@Transactional(rollbackFor = Exception.class)
public boolean register(Request request) {
    RLock lock = redisson.getLock(request.getIdentifier());
    try {
        //一锁
        lock.lock();

        //二查
        User user = userMapper.find(request.getIdentifier());
        if (user!=null) {
            return false;
        }

        //三更新，保存订单数据
        userMapper.insertOrder(request);
        
    } finally {
        lock.unlock();
    }

    return true;
}
```



按照这个顺序执行的：

1、进入事务

2、加锁

3、解锁

4、事务提交



这时候就会出现一种情况，在第三步和第四步中间，如果有一个其他线程调用这个方法，



那么会出现一个问题，锁已经释放了，但是事务还没有提交，这时候其他的线程在并发请求过来的时候：



一锁：拿锁可以拿到，因为锁被释放了

二查：查询数据也查不到，因为这时候之前的那个事务可能还没提交，未提交的数据，新的事务是看不到的。

三更新：执行更新操作，导致数据重复或者报错。



这就是我们需要解决的问题，那么看上去就是事务的切面执行顺序的问题，我们应该让锁的粒度更大一点，只要他大于事务的粒度就没问题了。



那么，就想办法让分布式锁的注解的切面先执行。解决方法就是借助@Order注解，它可以直接用于切面类上，用于指定切面的执行顺序，从小到大依次执行。



所以修改后的做法就是添加了一个@Order（Integer.MIN_VALUE)注解。



这样就可以让他优先执行。

