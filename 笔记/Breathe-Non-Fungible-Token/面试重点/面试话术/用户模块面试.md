### 你大概给我介绍一下用户模块实现了哪些功能?

我主要实现了用户模块的注册, 登录, 退出, 用户信息修改, 实名认证功能.

### 注册功能介绍一下?

注册前会让用户先调用发送验证码的接口去获取验证码, 注册功能我们这里是通过验证码注册的(验证码四位, 有效期5分钟), 这里使用到了一个自定义的滑动窗口, 这里我们是对reidisson的RRatelimiter进行了一层包装, 虽然他底层用的是令牌桶来实现的限流, 但是我们通过看他的lua脚本发现, 其实当限流为1分钟1次的时候, 他的效果和滑动窗口限流是完全一样的. 并且在这里我们不光在发送验证码的地方, 其实我们在短信服务也做了限流, 这个思想也是我在这个项目中学到的, 就是说我们无法完全去信任其他的模块, 即使其他的模块做了相关的校验, 但是我们的模块上也必须要做相关的处理, 而且短信服务他也是一个非常害怕被别人盗刷的服务, 我们必须要增强决策来减少损失.

首先我们会发送一个验证码, 然后以业务前缀 + 手机号为key, 验证码为value, 存到redis中, 利用JDK21的虚拟线程去发送短信, (这里我原先不是很了解虚拟线程的时候, 我认为他既然减少了开销, 那么我用一个线程池把他存起来不是更节省吗, 基于此我原本做了一个优化, 我自定义了一个线程池, 并且将线程工厂换成Thread.ofVirtual().factory(), 但是后来经过资料的查询发现, 虚拟线程是非常轻量的, 他和传统的线程不一样, 不需要去操作系统申请, 然后他开几百万个也不是问题, JDK团队设计理念就是"虚拟线程不要池化, 因为他们的创建成本和销毁成本很低").

当用户收到验证码以后, 我们会通过手机号, 拼接业务前缀去redis中获取, 如果获取到的验证码和他的一样的话, 就开始注册, 注册的话由于我们是有一个邀请码和积分机制, 有一个积分排行榜, 所以我们给用户分配用户名的时候是不可以冲突的, 用户名的组成为: 一个前缀 + 6位随机字母 + 数字 + 手机号后四位, 这里为了防止重复, 我们写了一个do-while循环, 如果从数据库中获取到用户名, 发现该用户名已存在, 就继续生成, 我们这里是认为冲突的概率不大, 因为毕竟是随机的6位字母 + 数字 + 手机号后4位, 值得说一下, 因为我们是有邀请排行榜的, 所以,我们的中间的6位字母 + 数字就充当了邀请码, 判断的时候, 如果邀请码重复了, 也需要重新生成用户名. 这里为了提高性能, 我们选择了用布隆过滤器来做一个优化,用于快速判断是否重复, 如果重复, 由于他的假阳性, 要去数据库中再查一下. 然后才能判断存不存在. 这个注册操作上加了一个分布式锁(这也是为了优化, 防止出现相同的用户名, 粒度是手机号), 然后如果有邀请码的话, 我们就可以给排行榜上的人加积分, 这里也加了一个锁, 粒度是邀请人的ID. 这个是因为在并发修改的时候， 我们的积分是如何加呢, 其实不是通过自增这样的原子操作, 而是通过获取到原先的值, 然后把本次要加的值加上去, 这就会导致一个并发问题, 如果有两个人同时注册, 同时对同一个邀请人进行积分的相加, 在这种并发情况下, 积分会只加一次. 因为get和set不是一个原子操作(在作者的实现中, 他是加了一个粒度为邀请人ID的分布式锁, 但是我认为只需要通过一个lua脚本执行就行, 因为导致这个问题的本质并不是因为什么, 只是由于这几个操作不是一个原子操作, 他是通过加锁的方式实现, 我是通过lua脚本的方式实现, 这种方式我认为比加锁更为高效, 因为加锁还涉及到释放锁之类的, 我这直接执行就OK), 在注册成功, 并且排行榜更新完毕后, 我们就可以登录这个账号了, 由于用户模块其实在其他比如说订单模块, 支付模块会频繁的用到用户的一些基本信息, 而且用户的信息变动的不频繁, 所以就把他加到了缓存中.

布隆过滤器容量设置的100000, 误判率为0.01

[布隆过滤器容量如何评估？ \| 大话面试](https://open8gu.com/redis/trending/sf9qpv78r4z7mlqd/)


## 登录功能介绍一下

登录功能其实就没有那么多的操作了, 它可以先发送一个验证码, 然后查一下这个手机号是否能登录, 如果没有注册的话, 就转到register的逻辑, 如果注册了的话, 就直接登录, 然后将token存到redis中方便判断用户登录的生命周期.

## 你在注册时提到了排行榜功能, 能大概介绍一下是如何实现的吗?

我的排行榜实现其实就是Redisson的RScoredSortedSet这个数据结构实现的, 这个其实也就是基于ZSET实现的. 其中每个数据有两个参数, 一个是score, 一个member, 然后基于score排序, 我们这里score存的就是每个人的积分, member就是每个人的id, 然后在更新的时候, 我们是通过lua脚本实现的, 保证了操作的原子性, 防止更新不成功, 但是如果只是单纯的用加减积分排序, 是很容易出现内种积分完全相同, 就无法知道排序结果了, 我们一般排序都是先基于积分, 然后基于时间, 先达到这个积分的靠前, 那么我们如何实现这个功能呢?就是把时间因素要加入其中, 我是通过整数部分放积分, 然后获取更新的时候的时间戳, 把他除以一个1e13, 把这个时间戳换成一个0开头的小数, 然后让他和积分相加, 但是这又会引发一个问题, 那就是时间戳是递增的, 这样只会导致后来的和用户排到了上面, 这个实现也很简单, 直接用1 - 这个值就可以实现, 先来的大, 后来的小.

### 你对于一些排行榜的实现有什么思考吗?

我之前是看过一些关于排行榜实现的文章, 其实主要还是基于ZSET的实现的, 但是由于数据量很大, 很容易导致一些问题, 比如说大key(这里要引申到大key的排查, [[✅什么是大Key问题，如何解决？]]), 再比如说数据量过大, 本身维护就很困难, 性能很低, 我们可以基于场景对他进行分片, 比如一个全国的排行榜, 我们可以现在每个省维护一个排行榜, 然后再全国排名的时候只取一个省的前多少名就可以了, 如果省还是多, 那就继续优化成一个市或县.

### 你说你对用户的信息做了一个缓存, 有没有对缓存信息做一致性的处理

是做了的, 缓存的一致性, 我的项目中主要用到了三种缓存一致性的方案, 分别是先写数据库后删缓存, 延迟双删, Cache-Aside (更新数据库,然后canal监听, 发送给rocketmq, mq发消息去更新redis), 这三种在我的项目中不同的场景下有着不同的使用, 在并发量不高的场景中, 我直接使用了先该数据库, 后删缓存.比如用户信息我们做了缓存，但是在用户状态发生变更时，我们需要同时更新缓存，所以这里就是典型的一个先更新数据库，然后再删除缓存的方案, 因为用户的信息变化并不是特别的频繁，所以其实并发量也不是很高，及时极端情况下出现缓存删除不及时，导致脏读也是可以接受的，所以我们选的是方案1 ，先更新数据库，再删除缓存。同时，为了避免这种极端的情况下出现的缓存删除失败导致的不一致的情况，我们也做了一些事情，比如我们在查询处都增加了缓存的自动刷新，到时间之后，缓存也能进行自动更新。

那在哪个地方使用了延迟双删呢? 其实也是用户模块, 我的用户有不同的状态, 比如[[用户状态机]], 在freeze和active中进行转换的话, 虽然并发量不高, 但因为涉及到是否能够购买藏品了, 我们希望能够快速的更新缓存, 不要缓存失败避免不一致, 所以引入了延迟双删.

什么是延迟双删呢? 就是在你第一次删除完缓存以后, 如果直接更新数据库, 然后在数据库更新前另一个线程获取到了这份未更新的数据, 并将他写入了缓存, 那么虽然你删了缓存, 也更新了数据库, 但是你获取到的不是最新的数据, 为了防止这种隐患, 我们使用了延迟双删. 我之前看过有些文章说第二次删除的时机不是很好把握, 这个延迟的原因是因为害怕虽然另一个线程读到了数据, 但是害怕他写不到redis中, 防止redis的写操作比myql的更新操作更久(这个我认为还是不太可能发生的, 之前看资料他们之间的速度差了几个数量级, 但是能够想到这种可能性的真的很强, 然后也是为了防止第一次删除缓存失败吧, 更保险一点).

### 关于这个延迟双删问题有什么想说的(其实可以在这个里面带出来)

关于延迟双删一致性的问题, 我认为就是要看场景, 我听过很多人对于该方案的看法, 其实大部分都不是很看好这个方案, 但是我个人比较喜欢, 他们不看好是因为, 认为先改后删也能保证可用和最终一致性, 这种方案显得非常的无用, 做了很多无用的操作, 回归到这个场景, 我认为就非常合适, 我们的目标是让他尽可能的感知到用户状态的变化, 因为是和购买相关的, 所以要尽可能减少不一致, 先改后删的话, 虽然他也能实现咱们的目的, 但是他和延迟双删来对比, 就显得没那么好了, 因为我们是想尽量减少不一致. 有个人告诉我, 那你不会加锁吗? 我仔细想了一下这个问题, 我认为在这里加锁并不能改变这个问题. 加锁的本质其实就是防止并发访问, 他的加锁可能是将这里的用户每次进行状态更新的时候都加锁, 然后访问的时候也加锁, 那我请问, 我们做缓存的目的是什么呢? 不就是为了增快访问速度吗, 如果你在一切访问的地方加锁, 其实就可以不用维护缓存的一致性了, 直接访问数据库, 在这里我认为延迟双删是一个比较这种并且比较适合的方案.