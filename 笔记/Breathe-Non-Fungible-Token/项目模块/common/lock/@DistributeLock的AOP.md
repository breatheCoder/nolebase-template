这里我们来介绍一下分布式锁的AOP如何实现的。



首先我们要知道注解中携带了哪些参数

[[@DistributeLock]]



因为他是分布式锁，是最特殊的，如果有其他AOP的话，他的执行顺序一定是最靠前的， 因为只有获取到锁才能够继续往下操作，要不然你的内些操作都是违规的。



所以我们这里使用了@Order注解，然后将注解的值设置为MIN_VALUE



在AOP的时候我们使用了@Around来做一个拦截，这样子可以在方法执行前获取锁，并且在方法执行后释放锁。



执行顺序是：

1. 找到方法名
2. 找到注解
3. 解析注解中的参数，首先看key是否为NONE，如果为NONE的话就看keyExpression是否为NONE，为NONE的话就使用默认的key，不为NONE的话，就将keyExpression的参数解析出来，赋值给key，<font style="color:#DF2A3F;">如果key一开始就有值的话，不用看KeyExpression，直接往下</font>
4. 将scene和key拼接到一起作为锁的key，并获取锁的过期事件和等待时间
5. 通过这两个事件分别对redissonClient获取到的lock来做一个判断和参数的放置，如果没有设置过期时间和等待时间的话，那么就会通过redissonClient来获取锁，并使用看门狗机制。
6. 下方对加锁结果进行一个判断，判断是否加锁成功，如果没有成功的话，打印对应的日志，并抛出分布式锁的异常
7. 如果成功的话，等待该方法执行完毕，然后在finally处解锁。最终返回response。

