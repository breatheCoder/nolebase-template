[[秒杀第二套方案：基于Redis+MQ+数据库实现高并发扣减]]

上面这套秒杀方案中, 订单的创建和数据库的扣减都是放在异步链路中的, 即在NewBuyBatchMsgListener/NewBuyMsgListener中监听到下单消息以后, 调用的createAndConfirm方法, 这个方法中, 是先扣减库存的, 然后再创建订单的.

![[Pasted image 20250815110957.png]]

之所以那么做, 有几个好处

1. 肯定不会出现 **超卖** 问题, 我们是在数据库库存扣减成功之后才会去创建订单, 这就能保证库存扣减了并且是持久化了, (数据库的ACID保证), 之后才会创建订单, 绝对没有可能出现超卖的情况. (库存没扣, 创建了订单)
2. 一致性更好, 这个方案中, 两个数据库的操作都放到了异步链路中, 任何一个步骤失败, MQ都会重投消息重试, 最终一致性更有保证.

但是这个方案也有一个很大的缺点, 那就是存在 **性能瓶颈** ,因为我们的订单创建是在库存扣减之后的, 而库存扣减在高并发的情况下就是一个数据库的热点操作, 热点操作就会导致执行存在延迟的情况, 经过我们的压测发现, 在并发数到达300的时候, redis的库存和数据库的扣减之间会存在11s-12s的延迟.

那么就意味着, 在并发数达到300的时候, 订单要有11-12s才能创建成功, 那么用户就需要在这个页面等这么久, 这样的话体验有点未免太差了.

而这个延迟没办法通过其他手段, 比如增加数据库的配置, 调整各种参数的优化什么的做优化了. 所以需要换一种方案来解决这种瓶颈.

所以这套方案适合用在, 并发不超过300, 或者超过300直接限流, 提示用户失败, 并对于一致性要求更高, 即不能接收超卖的场景.

要解决这个方案的瓶颈问题, 就是我们的第三套方案了.

