## 概述
这里我打算介绍我们常见的三种垃圾回收算法
1. 标记清除
2. 标记复制
3. 标记整理

## 分代收集理论
我们上面提到的三种，包括Java这么久一直以来都是在这种理论的基础上设计的垃圾回收机制。

这个理论是在三个假设的前提下的：
1. 弱分代假说：绝大部分对象是朝生夕死
2. 强分代假说：熬过越多次垃圾回收的对象就越难以死亡

基于这两个假说，Java也将堆分为了年轻代和老年代，年轻代存放年轻的对象，当对象熬过多次垃圾回收以后，就将他放到老年代中。并且通过这两个原则设计了多个垃圾回收器。

因为划分为了两个区域，才有了Minor GC，Major GC，FullGC。
但是单纯简单的区域划分，其实也是会有很多问题的，比如跨代引用的问题，我们是采用可达性分析算法来进行垃圾回收的，如果有一天老年代引用了年轻代的对象，但是我们进行Minor GC，没有办法发现老年代的引用将年轻代回收了怎么办。

这就要引出我们的第三个假设了
3. 跨代引用假说：跨代引用相当于同代引用来说仅占极少数。
这个其实是基于前两个假说的一个隐含条件，因为如果大部分对象朝生夕死，那么很快年轻的对象就自己over了，不会发生跨代引用，如果这个对象存活的很久，他就会变成老年代对象，就会变成同代引用，也不会发生跨代引用，所以说他的占比很少，既然他的占比少，我们肯定就不需要去每次的扫描整个年轻代和老年代。而且正是由于他的数量很少，我们才能使用记忆集和卡表去处理跨代引用的问题，不会造成太大的内存占用。

## 常见的垃圾收集方式
1. Minor GC：目标只是新生代的垃圾收集
2. Major GC：目标只是老年代的垃圾收集
3. Mixed GC：G1特有的行为，收集整个年轻代和部分老年代
4. Full GC：收集整个老年代和方法区。（最后，最大的收集了）

## 标记清除算法
这个算法是最早出现，也是最基础的垃圾回收算法。由Lisp提出，他的步骤正如他的名字一样，算法分成“标记”和“清除”两个阶段。
### 标记
标记可以标记一类对象，可以是需要回收的对象，也可以是存活对象
### 清除
标记完毕以后，直接进行清除
### 优点
简单，容易实现
### 缺点
在需要回收的对象特别多的场景下，我们的标记和清除的效率会随着对象的增加而降低。
通过标记清除得到的结果，会产生内存碎片，造成内存空间的不充分利用。
![[Pasted image 20250929112557.png]]

## 标记复制算法
这个算法也和他的名字一样，先标记再复制，他有两个区域，一个from区，一个to区，
### 标记
标记from存活对象
### 复制
将存活对象复制到to区，然后将from区清空。
完成以后更换from和to区的名字
### 优点
避免了标记清除算法中的内存碎片问题，而且处理也很高效，但是在多数对象都是存活的话，这个复制的效率就会降低，因为需要复制的太多了。
### 缺点
最明显的一个缺点就是，可以利用的内存空间直接砍半了，空间浪费未免太多了一点。
![[Pasted image 20250929114741.png]]
### 拓展
虽然标记复制算法会带来极大的内存浪费，但是经过一些公司的研究（比如IBM），发现这些朝生夕死的对象占了98%，这意味着我们并没必要将他们按1:1回收，所以就出现了“Appel式回收”，这种回收方式也正是JVM正在使用的，这更详细一点来说，其实是一种内存分配策略。我们将年轻代分为两个区：Eden区和Survivor区，Survivor又分为from区和to区，因为很多对象经历一次GC就回收了，所以，我们的内存分配就是Eden占8份，Survivor的from和to各占一份，每次回收都把存活对象放到to区，然后交换名字。

有人就要问了，如果有一次Minor GC，存活的对象数大于10%怎么办，这里有一个担保机制，如果你不够的话，我们就使用其他内存区域进行内存分配（大多数使用的老年代），我们就可以借用老年代的空间来存放年轻代的对象，这样就不害怕survivor存不下了。

## 标记整理算法
上面的标记复制算法在遇到很多对象长时间存活的话，他的复制的频率就很高，就会降低垃圾回收的效率，所以天然不适合老年代使用，更关键的是，他还需要直接占用一半的空间去复制，这显然是不能被老年代接受的，本来存活的对象就多，你还整这出。

所以我认为这种回收算法是为了老年代这种场景服务的。
### 标记
同标记清除算法的标记过程
### 整理
他会将存活对象整体一起往左边移动，然后就可以将剩余没有用到的对象全部清空。
### 拓展
大家是不是可以发现一个问题，像老年代这种，放了好多存活的对象的，如果要移动的话，是一个非常耗时的操作。

事实就是这样的，这也是不同的垃圾回收器针对这个问题做了不同的优化的地方，代表就是CMS和G1

但是如果不使用这种方式的话，其实就和标记清除算法一样了，内中方式又会使空间得不到充分利用，维护这些零碎的内存空间也是一个不小的消耗，不管移不移都会有弊端。

这里有一种取巧的方式，道理就类似于一些东西，先本地处理，然后定期向远端同步（这个例子可能不太合适，但是了解这种分散再合适的思想就行），我们是不是可以日常先使用标记清除算法，让他耗时变少，当内存碎片最后影响的不行不行的时候，我们再使用标记整理算法来对空间进行整理。
![[Pasted image 20250929143756.png]]