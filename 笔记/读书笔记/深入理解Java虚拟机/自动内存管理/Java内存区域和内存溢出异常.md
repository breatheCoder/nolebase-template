## 概述

对于内存的管理，Java和C++程序员有着截然不同的处理方法和处理难度，对于C++程序员来说，他就是所有对象的母亲，他负责所有对象的生存和消亡，非常的繁琐，但是对于问题的发生和排查基本都是自己的代码导致的，排查的难度没有Java的大，那么Java的为什么大呢？因为我们自始自终都没有亲自管理过内存和对象的分配和存储，我们一直依赖于Java虚拟机，这就导致了一旦出现内存溢出或内存泄漏的问题，Java程序员的排查是很困难的，一个是因为不了解，一个是因为Java虚拟机将这些操作隐藏起来了，不好发现。

下面介绍一下运行时数据区：

它分为两部分：

- 线程隔离
	- 虚拟机栈
	- 本地方法栈
	- 程序计数器
- 线程不隔离
	- 方法区
	- 堆区

## Java运行时区域

### 程序计数器

程序计数器(PC)是一块较小的内存空间,它可以看作是当前线程锁执行的字节码的行号指示器. 在Java虚拟机的概念模型里, 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令, 由于他是记录下一个指令的地址的, 所以他是运行时数据区唯一一个不会发生内存泄漏和溢出的区域(不会OOM). 他是程序控制流的指示器, 分支, 循环, 跳转, 异常处理, 线程恢复等基础功能都需要依赖这个计数器完成.

由于Java虚拟机的多线程是通过多个线程轮换, 然后分配处理器执行时间的方式来实现的, 所以在任何一个时刻, 一个处理器都只会执行一个线程中的指令, 所以为了线程切换后恢复到正确的位置和可以知道他执行到哪里, 每个线程都要有一个独立的程序计数器, 各个线程的程序计数器互不影响, 独立存储, 我们称这类内存区域为"线程私有"的内存

如果线程正在执行的是一个Java方法, 这个计数器记录的是正在执行的虚拟机字节码指令的地址, 如果正在执行的是本地(native)方法, 这个计数器应该为空(undefined)

### Java虚拟机栈

与程序计数器一样, Java虚拟机栈也是每一个线程一个私有的, 他的生命周期和线程相同, 虚拟机栈描述的是Java方法执行的线程内存模型, 每个方法在执行的时候, Java虚拟机都会同步创建一个栈帧用于存储局部变量表, 操作数栈, 动态链接, 方法出口等信息, 每一个方法从调用到结束就对应着从入栈到出栈的过程.

经常有人把Java的内存区域简单的划分为堆区和栈区, 这种划分方式直接继承自传统的C, C++程序的内存布局结构, 在Java语言中就显得有些粗糙了, 实际的内存区域划分要比这更复杂, 但是这也正反映了程序员最关注的也就是这两块区域.

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型(boolean, byte, char, short, int, float, long, double), 对象引用(reference类型, 它并不等同于对象本身, 可能是一个指向对象起始地址的指针, 也可能是指向一个代表对象的句柄或者其他与此对象相关的位置) 和returnAddress类型

这些数据类型在局部变量表中的存储空间以局部变量槽(slot)来表示, long和double会占用两个slot, 其余只占一个slot, 局部变量表所需的内存空间在编译期间完成分配, 当进入一个方法时, 这个方法需要在栈帧中分配多大的局部变量空间是已经确定的, 在方法运行期间不会改变局部变量表的大小. 这里说的 "大小" 是空间完全确定的, 虚拟机真正使用多大的内存空间, 比如一个slot占32bit或者占64bit, 这是完全由虚拟机决定的.

在Java虚拟机规范中, 对这个内存区域规定了两类异常的情况: 如果线程请求的深度大于虚拟线程所允许的最大深度, 则会抛出StackOverflowError异常, 如果Java虚拟机栈容量可以动态扩展, 当栈扩展时无法申请到足够的内存或抛出OOM异常.

HotSpot虚拟机的栈容量是无法动态扩展的, 以前的Classic虚拟机可以, 所以HotSpot虚拟机上是不会由于虚拟机栈无法扩展导致OOM, 只要栈空间申请成功了就不会OOM, 如果申请失败, 是会出现OOM的

### 本地方法栈

在我的理解里, 它和Java虚拟机栈的作用几乎是相同的, 只是服务的对象不同, Java虚拟机栈是给Java虚拟机中运行的程序所执行的方法使用的, 本地方法栈是给native方法使用的. Java虚拟机规范并没有对本地方法栈中方法使用的语言, 使用方式与数据结构没有强制规定, 因此具体的虚拟机可以根据需要自由实现它, 甚至有的Java虚拟机(HotSpot)直接将本地方法栈和虚拟机栈合二为一, 和虚拟机栈一样, 本地方法站也会在栈深度溢出或栈扩展失败的时候分别抛出SOF和OOM.

### Java堆

对于Java应用程序来说, Java堆可以说是虚拟机管理的最大的一块内存区域了, Java堆是被所有线程共享的一块内存区域, 在Java虚拟机规范说, 此内存区域唯一的目的就是为了存放对象实例, Java世界几乎 "所有的" 对象实例都在这里被分配, 虽然Java虚拟机规范说Java所有的对象实例都在堆上, 但是为什么这里用了几乎呢? 因为随着Java语言的发展, 我们已经能看到些许迹象表明日后可能出现值类型的支持, 即使只考虑现在, 由于即时编译技术的进步, 尤其是逃逸分析技术的日渐强大, 栈上分配, 标量替换优化手段已经导致为秒的变化悄然发生.

Java堆是垃圾回收器管理的内存区域, 因此一些资料也称它为GC堆(Garbage Collected Heap). 

从回收内存的角度看, 由于现代垃圾回收器大部分都是基于分代收集理论设计的, 所以Java堆中经常会出现 "新生代" "老年代" "永久代" "eden空间" "from survivor空间" "to survivor空间" 等名词, 这些只是一部分垃圾回收器的共同特性, 并不是某个Java虚拟机实现的固有内存布局, 更不是Java虚拟机规范说的.

从分配内存的角度看, 所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区, 以提升对象分配时的效率.

不过不管从哪个角度, 无论如何划分, 都不会改变Java堆种存储内容的共性, 无论是哪个区域, 存储的都只是对象的实例, 将Java堆细分的目的只是为了 "更好的回收内存", 或者 "更快的分配内存". 

### 方法区

方法区和Java堆一样, 是各个线程共享的内存区域, 它用于存储已被虚拟机加载的类型信息, 常量, 静态常量, 即使编译器编译后的代码缓存等数据. 虽然Java虚拟机规范把方法去描述为堆的一个逻辑部分, 但是它却又一个别名叫做Non-Heap(非堆), 目的是与Java堆区域区分开

说到方法区, 不得不提一下 "永久代" 这个概念, 尤其是在JDK8以前, 许多Java程序员你都习惯在HotSpot虚拟机上开发, 部署程序, 很多人都更愿意把方法去称呼为 "永久代" 或将两者混为一谈, 本质上两者并不是等价的, 因为仅仅是当时的HotSpot虚拟机设计团队把收集器的分代设计扩展到方法区, 或者说使用永久代来实现方法区而已, 这样使得HotSpot的垃圾回收器能像管理Java堆一样管理者部分内存, 最后因为放到永久代太不合适了, 老是内存溢出, 所以就借鉴J9等虚拟机的实践, 放到了本地内存中, 也就是我们熟知的元空间

### 运行时常量池

运行时常量池是方法区的一部分. Class文件中除了有类的版本, 字段, 犯法, 接口等描述信息意外, 还有一项信息是常量池表, 用于存放编译器生成的各种字面量与符号引用, 这部分内容将在类加载后存放到方法去的运行时常量池中.

Java虚拟机对于class文件中的每一部分(自然也包括常量池)的格式都有严格规定, 如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可, 加载和执行. 但对于运行时常量池, Java虚拟机规范并没有做任何细节的要求, 不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域, 不过一般来说, 除了保存class文件中描述的符号引用意外, 还会把由符号引用翻译出来的直接引用也存储在运行时常量池中.

运行时常量池相对于class文件常量池的另外一个重要特征是具有动态性, Java语言并不要求常量池, 运行期间也可以将新的常量放到池中, 这种特性被开发人员利用的比较多的便是String的intern方法.

既然运行时常量池是方法区的一部分, 自然收到方法区内存的限制, 当常量池无法再申请到内存时会抛出OOM异常.

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分, 也不是Java虚拟机规范中定义的内存区域, 但是这部分内存也被频繁的使用, 而且也可能导致OOM的出现, 所以我们放到这里一起讲解.

在JDK1.4开始加入了NIO类, 引入了一种基于通道与缓冲区的IO方式. 它可以使用native函数库直接分配堆外内存, 然后通过一个存储在Java堆里面的directByteBuffer对象作为这块内存的引用进行操作. 这样能在一些场景下能显著提高性能, 因为避免了在Java堆和native堆中来回复制数据.

显然本机直接分配的内存不会收到Java堆大小的限制, 但是既然是内存, 肯定还会收到总内存的限制, 一般服务器管理员配置虚拟机参数的时候, 会根据实际内存区调整-Xmx等参数信息, 但是经常忽略掉直接内存, 是的各个内存区域综合大于物理内存限制, 从而导致动态扩展的时候出现OOM.

## HotSpot虚拟机对象探秘

这里以Java堆为例, 深入探讨HotSpot虚拟机在Java堆中对象分配, 布局和访问的全过程.

### 对象的创建

Java是一门面向对象的语言, Java程序运行过程中无时无刻都有对象被创建出来, 在语言层面上, 创建对象通常仅仅只是一个new关键字而已, 而在虚拟机中(我们这里只谈论普通的new对象, 不包括数组和class对象)的创建又是一个怎样的过程呢?

当Java虚拟机遇到一个字节码new指令的时候, 首先将检查这个指令的参数是否能在常量池中定位到一个类的符号引用, 并且检查这个符号引用代表的类是否已经被加载, 链接, 初始化过, 如果没有, 那就要走一遍类的加载过程, 这里就不详细说了, 之后再聊.

在类加载检查通过后, 接下来虚拟机将为新生对象分配内存, 对象所需内存的大小在类加载完成后遍可完全确定, 为对象分配空间的任务实际上边等同于吧一块确定大小的内存块从Java堆种划分出来. 假设Java堆中内存是绝对规整的, 所有被使用过的内存都被放在一遍, 空闲的内存被放在另一边, 中间放着一个指针作为分界点的指示器, 那所分配内存就仅仅是吧那个指针向空闲防线挪动一段与对象大小相等的具体, 这种分配方式叫做 "指针碰撞", 但如果Java堆种的内存并不是规整的, 已被使用的内存和空闲的内存相互交错在一起, 那就没有办法进行简单的指针碰撞了, 虚拟机必须维护一个列表, 记录上哪些内存块是可用的, 在分配的时候从列表中找到一个足够大的空间划分给对象实例, 并更新列表上的记录, 这种分配方式称为空闲列表(free list), 选择哪种分配方式是由Java堆是否整齐决定, 是否整齐又是由垃圾回收策略决定(是否携带compact的能力), 因此, 当使用Serial, ParNew等带压缩整理过程的收集器的时候, 系统采用的分配算法是指针碰撞, 既简单又高效, 而当使用CMS这种基于清除(Sweep)算法的收集器的时候, 理论上就只能采用较为复杂的空闲列表来分配内存.

除了如何划分空间以外, 还有一个另一个需要考虑的问题, 对象创建在虚拟机中是非常频繁的行为, 即使仅仅修改一个指针所指向的位置, 在并发情况下, 也并不是线程安全的, 可能出现正在给A分配内存, 对象B又同时使用了原来的指针分配内存的情况, 导致多分配了. 解决这个问题有两种可选方案: 
- 一种是堆分配内存空间的操作进行同步处理 -- 实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性
- 另一种是把内存分配的动作按照线程划分在不同的空间之中进行, 即每个线程在Java堆种预先分配一小块内存, 称为本地线程分配缓冲(这就是我们前面提到的), 哪个线程需要分配内存, 就在哪个线程的本地缓冲区中分配, 只有本地缓冲区用完了, 分配新的缓冲区才需要同步锁定. 虚拟机是否使用本地线程分配缓冲, 可以通过-XX: +/-UseTLAB参数来设定.
